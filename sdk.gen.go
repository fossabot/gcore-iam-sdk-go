// Package sdk provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package sdk

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerScopes = "Bearer.Scopes"
)

// Defines values for PostClientsInviteUserJSONBodyLang.
const (
	PostClientsInviteUserJSONBodyLangAz PostClientsInviteUserJSONBodyLang = "az"
	PostClientsInviteUserJSONBodyLangDe PostClientsInviteUserJSONBodyLang = "de"
	PostClientsInviteUserJSONBodyLangEn PostClientsInviteUserJSONBodyLang = "en"
	PostClientsInviteUserJSONBodyLangRu PostClientsInviteUserJSONBodyLang = "ru"
	PostClientsInviteUserJSONBodyLangZh PostClientsInviteUserJSONBodyLang = "zh"
)

// Defines values for PostClientsInviteUserJSONBodyUserRoleName.
const (
	PostClientsInviteUserJSONBodyUserRoleNameAdministrators             PostClientsInviteUserJSONBodyUserRoleName = "Administrators"
	PostClientsInviteUserJSONBodyUserRoleNameEngineers                  PostClientsInviteUserJSONBodyUserRoleName = "Engineers"
	PostClientsInviteUserJSONBodyUserRoleNamePurgeAndPrefetchOnlyAPI    PostClientsInviteUserJSONBodyUserRoleName = "Purge and Prefetch only (API)"
	PostClientsInviteUserJSONBodyUserRoleNamePurgeAndPrefetchOnlyAPIWeb PostClientsInviteUserJSONBodyUserRoleName = "Purge and Prefetch only (API+Web)"
	PostClientsInviteUserJSONBodyUserRoleNameUsers                      PostClientsInviteUserJSONBodyUserRoleName = "Users"
)

// Defines values for PutClientsClientIdClientUsersUserIdJSONBodyUserRoleName.
const (
	PutClientsClientIdClientUsersUserIdJSONBodyUserRoleNameAdministrators             PutClientsClientIdClientUsersUserIdJSONBodyUserRoleName = "Administrators"
	PutClientsClientIdClientUsersUserIdJSONBodyUserRoleNameEngineers                  PutClientsClientIdClientUsersUserIdJSONBodyUserRoleName = "Engineers"
	PutClientsClientIdClientUsersUserIdJSONBodyUserRoleNamePurgeAndPrefetchOnlyAPI    PutClientsClientIdClientUsersUserIdJSONBodyUserRoleName = "Purge and Prefetch only (API)"
	PutClientsClientIdClientUsersUserIdJSONBodyUserRoleNamePurgeAndPrefetchOnlyAPIWeb PutClientsClientIdClientUsersUserIdJSONBodyUserRoleName = "Purge and Prefetch only (API+Web)"
	PutClientsClientIdClientUsersUserIdJSONBodyUserRoleNameUsers                      PutClientsClientIdClientUsersUserIdJSONBodyUserRoleName = "Users"
)

// Defines values for PostClientsClientIdTokensJSONBodyClientUserRoleName.
const (
	PostClientsClientIdTokensJSONBodyClientUserRoleNameAdministrators             PostClientsClientIdTokensJSONBodyClientUserRoleName = "Administrators"
	PostClientsClientIdTokensJSONBodyClientUserRoleNameEngineers                  PostClientsClientIdTokensJSONBodyClientUserRoleName = "Engineers"
	PostClientsClientIdTokensJSONBodyClientUserRoleNamePurgeAndPrefetchOnlyAPI    PostClientsClientIdTokensJSONBodyClientUserRoleName = "Purge and Prefetch only (API)"
	PostClientsClientIdTokensJSONBodyClientUserRoleNamePurgeAndPrefetchOnlyAPIWeb PostClientsClientIdTokensJSONBodyClientUserRoleName = "Purge and Prefetch only (API+Web)"
	PostClientsClientIdTokensJSONBodyClientUserRoleNameUsers                      PostClientsClientIdTokensJSONBodyClientUserRoleName = "Users"
)

// Defines values for PatchUsersUserIdJSONBodyAuthTypes.
const (
	PatchUsersUserIdJSONBodyAuthTypesGithub       PatchUsersUserIdJSONBodyAuthTypes = "github"
	PatchUsersUserIdJSONBodyAuthTypesGoogleOauth2 PatchUsersUserIdJSONBodyAuthTypes = "google-oauth2"
	PatchUsersUserIdJSONBodyAuthTypesPassword     PatchUsersUserIdJSONBodyAuthTypes = "password"
	PatchUsersUserIdJSONBodyAuthTypesSso          PatchUsersUserIdJSONBodyAuthTypes = "sso"
)

// Defines values for PatchUsersUserIdJSONBodyGroupsName.
const (
	PatchUsersUserIdJSONBodyGroupsNameAdministrators             PatchUsersUserIdJSONBodyGroupsName = "Administrators"
	PatchUsersUserIdJSONBodyGroupsNameEngineers                  PatchUsersUserIdJSONBodyGroupsName = "Engineers"
	PatchUsersUserIdJSONBodyGroupsNamePurgeAndPrefetchOnlyAPI    PatchUsersUserIdJSONBodyGroupsName = "Purge and Prefetch only (API)"
	PatchUsersUserIdJSONBodyGroupsNamePurgeAndPrefetchOnlyAPIWeb PatchUsersUserIdJSONBodyGroupsName = "Purge and Prefetch only (API+Web)"
	PatchUsersUserIdJSONBodyGroupsNameUsers                      PatchUsersUserIdJSONBodyGroupsName = "Users"
)

// Defines values for PatchUsersUserIdJSONBodyLang.
const (
	PatchUsersUserIdJSONBodyLangAz PatchUsersUserIdJSONBodyLang = "az"
	PatchUsersUserIdJSONBodyLangDe PatchUsersUserIdJSONBodyLang = "de"
	PatchUsersUserIdJSONBodyLangEn PatchUsersUserIdJSONBodyLang = "en"
	PatchUsersUserIdJSONBodyLangRu PatchUsersUserIdJSONBodyLang = "ru"
	PatchUsersUserIdJSONBodyLangZh PatchUsersUserIdJSONBodyLang = "zh"
)

// Defines values for PatchUsersUserIdJSONBodyUserType.
const (
	PatchUsersUserIdJSONBodyUserTypeCommon PatchUsersUserIdJSONBodyUserType = "common"
)

// GetActivityLogLoginsParams defines parameters for GetActivityLogLogins.
type GetActivityLogLoginsParams struct {
	// Limit The maximum number of items.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Offset relative to the beginning of list.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// PostAuthJwtLoginJSONBody defines parameters for PostAuthJwtLogin.
type PostAuthJwtLoginJSONBody struct {
	// OneTimePassword User's authenticator passcode in case of enabled 2fa.
	OneTimePassword *string `json:"one_time_password,omitempty"`

	// Password User's password.
	Password string `json:"password"`

	// Username User's email address.
	Username string `json:"username"`
}

// PostAuthJwtRefreshJSONBody defines parameters for PostAuthJwtRefresh.
type PostAuthJwtRefreshJSONBody struct {
	// Refresh Use this token to refresh the access token via
	// [`/auth/jwt/refresh`](#tag/Account/paths/~1auth~1jwt~1refresh/post) method.
	Refresh string `json:"refresh"`
}

// PostAuthPasswordForgotJSONBody defines parameters for PostAuthPasswordForgot.
type PostAuthPasswordForgotJSONBody struct {
	// Email User's email address.
	Email openapi_types.Email `json:"email"`
}

// PostClientsCreateJSONBody defines parameters for PostClientsCreate.
type PostClientsCreateJSONBody struct {
	// Company The company name.
	Company string `json:"company"`

	// Id The ID of the created account.
	Id *int `json:"id,omitempty"`
}

// PostClientsInviteUserJSONBody defines parameters for PostClientsInviteUser.
type PostClientsInviteUserJSONBody struct {
	// ClientId ID of account.
	ClientId int `json:"client_id"`

	// Email User email.
	Email openapi_types.Email `json:"email"`

	// Lang User's language.
	//
	// Defines language of the control panel and email messages.
	Lang *PostClientsInviteUserJSONBodyLang `json:"lang,omitempty"`

	// Name User name.
	Name     *string `json:"name,omitempty"`
	UserRole struct {
		// Id Group&#39;s ID: Possible values are: <br> <ul> <li>1 - Administrators <li>2 - Users <li>5 - Engineers <li>3009 - Purge and Prefetch only (API+Web) <li>3022 - Purge and Prefetch only (API)
		Id *int `json:"id,omitempty"`

		// Name Group's name.
		Name *PostClientsInviteUserJSONBodyUserRoleName `json:"name,omitempty"`
	} `json:"user_role"`
}

// PostClientsInviteUserJSONBodyLang defines parameters for PostClientsInviteUser.
type PostClientsInviteUserJSONBodyLang string

// PostClientsInviteUserJSONBodyUserRoleName defines parameters for PostClientsInviteUser.
type PostClientsInviteUserJSONBodyUserRoleName string

// PutClientsClientIdClientUsersUserIdJSONBody defines parameters for PutClientsClientIdClientUsersUserId.
type PutClientsClientIdClientUsersUserIdJSONBody struct {
	UserRole *struct {
		// Id Group&#39;s ID: Possible values are: <br> <ul> <li>1 - Administrators <li>2 - Users <li>5 - Engineers <li>3009 - Purge and Prefetch only (API+Web) <li>3022 - Purge and Prefetch only (API)
		Id *int `json:"id,omitempty"`

		// Name Group's name.
		Name *PutClientsClientIdClientUsersUserIdJSONBodyUserRoleName `json:"name,omitempty"`
	} `json:"user_role,omitempty"`
}

// PutClientsClientIdClientUsersUserIdJSONBodyUserRoleName defines parameters for PutClientsClientIdClientUsersUserId.
type PutClientsClientIdClientUsersUserIdJSONBodyUserRoleName string

// GetClientsClientIdTokensParams defines parameters for GetClientsClientIdTokens.
type GetClientsClientIdTokensParams struct {
	// Role Group&#39;s ID. Possible values are: <br> <ul> <li>1 - Administrators <li>2 - Users <li>5 - Engineers <li>3009 - Purge and Prefetch only (API+Web) <li>3022 - Purge and Prefetch only (API) </ul> Example, <i>&role=Engineers</i>
	Role *string `form:"role,omitempty" json:"role,omitempty"`

	// IssuedBy User&#39;s ID. Use to get API tokens issued by a particular user. <br> Example, <i>&issued_by=1234</i>
	IssuedBy *int `form:"issued_by,omitempty" json:"issued_by,omitempty"`

	// NotIssuedBy User&#39;s ID. Use to get API tokens issued by anyone except a particular user. <br> Example, <i>&not_issued_by=1234</i>
	NotIssuedBy *int `form:"not_issued_by,omitempty" json:"not_issued_by,omitempty"`

	// Deleted The state of API tokens included in the response. <br> Two possible values: <br> <ul> <li> True - API token was not deleted. <li> False - API token was deleted. </ul> Example, <i>&deleted=True</i>
	Deleted *bool `form:"deleted,omitempty" json:"deleted,omitempty"`
}

// PostClientsClientIdTokensJSONBody defines parameters for PostClientsClientIdTokens.
type PostClientsClientIdTokensJSONBody struct {
	// ClientUser API token role.
	ClientUser struct {
		Role *struct {
			// Id Group&#39;s ID: Possible values are: <br> <ul> <li>1 - Administrators <li>2 - Users <li>5 - Engineers <li>3009 - Purge and Prefetch only (API+Web) <li>3022 - Purge and Prefetch only (API)
			Id *int `json:"id,omitempty"`

			// Name Group's name.
			Name *PostClientsClientIdTokensJSONBodyClientUserRoleName `json:"name,omitempty"`
		} `json:"role,omitempty"`
	} `json:"client_user"`

	// Description API token description.
	Description *string `json:"description,omitempty"`

	// ExpDate Date when the API token becomes expired (ISO 8086/RFC 3339 format), UTC.
	// If null, then the API token will never expire.
	ExpDate *string `json:"exp_date,omitempty"`

	// Name API token name.
	Name string `json:"name"`
}

// PostClientsClientIdTokensJSONBodyClientUserRoleName defines parameters for PostClientsClientIdTokens.
type PostClientsClientIdTokensJSONBodyClientUserRoleName string

// GetUsersParams defines parameters for GetUsers.
type GetUsersParams struct {
	// Limit The maximum number of items.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Offset relative to the beginning of list.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// PatchUsersUserIdJSONBody defines parameters for PatchUsersUserId.
type PatchUsersUserIdJSONBody struct {
	// Activated Email confirmation:
	// - `true` – user confirmed the email;
	// - `false` – user did not confirm the email.
	Activated *bool `json:"activated,omitempty"`

	// AuthTypes System field. List of auth types available for the account.
	AuthTypes *[]PatchUsersUserIdJSONBodyAuthTypes `json:"auth_types,omitempty"`

	// Client User's  account ID.
	Client *float32 `json:"client,omitempty"`

	// Company User's company.
	Company *string `json:"company,omitempty"`

	// Deleted Deletion flag. If `true` then user was deleted.
	Deleted *bool `json:"deleted,omitempty"`

	// Email User's email address.
	Email *openapi_types.Email `json:"email,omitempty"`

	// Groups User's group in the current account.
	//
	// IAM supports 5 groups:
	//
	//   - Users
	//   - Administrators
	//   - Engineers
	//   - Purge and Prefetch only (API)
	//   - Purge and Prefetch only (API+Web)
	Groups *[]struct {
		// Id Group&#39;s ID: Possible values are: <br> <ul> <li>1 - Administrators <li>2 - Users <li>5 - Engineers <li>3009 - Purge and Prefetch only (API+Web) <li>3022 - Purge and Prefetch only (API)
		Id *int `json:"id,omitempty"`

		// Name Group's name.
		Name *PatchUsersUserIdJSONBodyGroupsName `json:"name,omitempty"`
	} `json:"groups,omitempty"`

	// Id User's ID.
	Id *int `json:"id,omitempty"`

	// Lang User's language.
	//
	// Defines language of the control panel and email messages.
	Lang *PatchUsersUserIdJSONBodyLang `json:"lang,omitempty"`

	// Name User's name.
	Name *string `json:"name"`

	// Phone User's phone.
	Phone *string `json:"phone"`

	// Reseller Services provider ID.
	Reseller *int `json:"reseller,omitempty"`

	// SsoAuth SSO authentication flag. If `true` then user can login via SAML SSO.
	SsoAuth *bool `json:"sso_auth,omitempty"`

	// TwoFa Two-step verification:
	//   - `true` – user enabled two-step verification;
	//   - `false` – user disabled two-step verification.
	TwoFa *bool `json:"two_fa,omitempty"`

	// UserType User's type.
	UserType *PatchUsersUserIdJSONBodyUserType `json:"user_type,omitempty"`
}

// PatchUsersUserIdJSONBodyAuthTypes defines parameters for PatchUsersUserId.
type PatchUsersUserIdJSONBodyAuthTypes string

// PatchUsersUserIdJSONBodyGroupsName defines parameters for PatchUsersUserId.
type PatchUsersUserIdJSONBodyGroupsName string

// PatchUsersUserIdJSONBodyLang defines parameters for PatchUsersUserId.
type PatchUsersUserIdJSONBodyLang string

// PatchUsersUserIdJSONBodyUserType defines parameters for PatchUsersUserId.
type PatchUsersUserIdJSONBodyUserType string

// PutUsersUserIdEmailJSONBody defines parameters for PutUsersUserIdEmail.
type PutUsersUserIdEmailJSONBody struct {
	// NewEmail User's new email.
	NewEmail string `json:"new_email"`

	// Password User's password for approve.
	Password string `json:"password"`
}

// PutUsersUserIdPasswordJSONBody defines parameters for PutUsersUserIdPassword.
type PutUsersUserIdPasswordJSONBody struct {
	// Double Confirm your new password.
	Double string `json:"double"`

	// New Your new password.
	New string `json:"new"`

	// Old Your old password.
	Old string `json:"old"`
}

// PostAuthJwtLoginJSONRequestBody defines body for PostAuthJwtLogin for application/json ContentType.
type PostAuthJwtLoginJSONRequestBody PostAuthJwtLoginJSONBody

// PostAuthJwtRefreshJSONRequestBody defines body for PostAuthJwtRefresh for application/json ContentType.
type PostAuthJwtRefreshJSONRequestBody PostAuthJwtRefreshJSONBody

// PostAuthPasswordForgotJSONRequestBody defines body for PostAuthPasswordForgot for application/json ContentType.
type PostAuthPasswordForgotJSONRequestBody PostAuthPasswordForgotJSONBody

// PostClientsCreateJSONRequestBody defines body for PostClientsCreate for application/json ContentType.
type PostClientsCreateJSONRequestBody PostClientsCreateJSONBody

// PostClientsInviteUserJSONRequestBody defines body for PostClientsInviteUser for application/json ContentType.
type PostClientsInviteUserJSONRequestBody PostClientsInviteUserJSONBody

// PutClientsClientIdClientUsersUserIdJSONRequestBody defines body for PutClientsClientIdClientUsersUserId for application/json ContentType.
type PutClientsClientIdClientUsersUserIdJSONRequestBody PutClientsClientIdClientUsersUserIdJSONBody

// PostClientsClientIdTokensJSONRequestBody defines body for PostClientsClientIdTokens for application/json ContentType.
type PostClientsClientIdTokensJSONRequestBody PostClientsClientIdTokensJSONBody

// PatchUsersUserIdJSONRequestBody defines body for PatchUsersUserId for application/json ContentType.
type PatchUsersUserIdJSONRequestBody PatchUsersUserIdJSONBody

// PutUsersUserIdEmailJSONRequestBody defines body for PutUsersUserIdEmail for application/json ContentType.
type PutUsersUserIdEmailJSONRequestBody PutUsersUserIdEmailJSONBody

// PutUsersUserIdPasswordJSONRequestBody defines body for PutUsersUserIdPassword for application/json ContentType.
type PutUsersUserIdPasswordJSONRequestBody PutUsersUserIdPasswordJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// ClientSDK which conforms to the OpenAPI3 specification for this service.
type ClientSDK struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*ClientSDK) error

// Creates a new ClientSDK, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*ClientSDK, error) {
	// create a client with sane default values
	client := ClientSDK{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *ClientSDK) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *ClientSDK) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetActivityLogLogins request
	GetActivityLogLogins(ctx context.Context, params *GetActivityLogLoginsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthJwtClientsClientIdLogin request
	GetAuthJwtClientsClientIdLogin(ctx context.Context, clientId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthJwtLoginWithBody request with any body
	PostAuthJwtLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuthJwtLogin(ctx context.Context, body PostAuthJwtLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthJwtRefreshWithBody request with any body
	PostAuthJwtRefreshWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuthJwtRefresh(ctx context.Context, body PostAuthJwtRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthPasswordForgotWithBody request with any body
	PostAuthPasswordForgotWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuthPasswordForgot(ctx context.Context, body PostAuthPasswordForgotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostClientsCreateWithBody request with any body
	PostClientsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostClientsCreate(ctx context.Context, body PostClientsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostClientsInviteUserWithBody request with any body
	PostClientsInviteUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostClientsInviteUser(ctx context.Context, body PostClientsInviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientsMe request
	GetClientsMe(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteClientsClientIdClientUsersUserId request
	DeleteClientsClientIdClientUsersUserId(ctx context.Context, clientId int, userId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientsClientIdClientUsersUserId request
	GetClientsClientIdClientUsersUserId(ctx context.Context, clientId int, userId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutClientsClientIdClientUsersUserIdWithBody request with any body
	PutClientsClientIdClientUsersUserIdWithBody(ctx context.Context, clientId int, userId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutClientsClientIdClientUsersUserId(ctx context.Context, clientId int, userId int, body PutClientsClientIdClientUsersUserIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientsClientIdTokens request
	GetClientsClientIdTokens(ctx context.Context, clientId int, params *GetClientsClientIdTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostClientsClientIdTokensWithBody request with any body
	PostClientsClientIdTokensWithBody(ctx context.Context, clientId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostClientsClientIdTokens(ctx context.Context, clientId int, body PostClientsClientIdTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteClientsClientIdTokensTokenId request
	DeleteClientsClientIdTokensTokenId(ctx context.Context, clientId int, tokenId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientsClientIdTokensTokenId request
	GetClientsClientIdTokensTokenId(ctx context.Context, clientId int, tokenId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsers request
	GetUsers(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersUserId request
	GetUsersUserId(ctx context.Context, userId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchUsersUserIdWithBody request with any body
	PatchUsersUserIdWithBody(ctx context.Context, userId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchUsersUserId(ctx context.Context, userId int, body PatchUsersUserIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutUsersUserIdEmailWithBody request with any body
	PutUsersUserIdEmailWithBody(ctx context.Context, userId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutUsersUserIdEmail(ctx context.Context, userId int, body PutUsersUserIdEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutUsersUserIdPasswordWithBody request with any body
	PutUsersUserIdPasswordWithBody(ctx context.Context, userId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutUsersUserIdPassword(ctx context.Context, userId int, body PutUsersUserIdPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *ClientSDK) GetActivityLogLogins(ctx context.Context, params *GetActivityLogLoginsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActivityLogLoginsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) GetAuthJwtClientsClientIdLogin(ctx context.Context, clientId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthJwtClientsClientIdLoginRequest(c.Server, clientId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) PostAuthJwtLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthJwtLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) PostAuthJwtLogin(ctx context.Context, body PostAuthJwtLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthJwtLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) PostAuthJwtRefreshWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthJwtRefreshRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) PostAuthJwtRefresh(ctx context.Context, body PostAuthJwtRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthJwtRefreshRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) PostAuthPasswordForgotWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthPasswordForgotRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) PostAuthPasswordForgot(ctx context.Context, body PostAuthPasswordForgotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthPasswordForgotRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) PostClientsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClientsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) PostClientsCreate(ctx context.Context, body PostClientsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClientsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) PostClientsInviteUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClientsInviteUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) PostClientsInviteUser(ctx context.Context, body PostClientsInviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClientsInviteUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) GetClientsMe(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientsMeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) DeleteClientsClientIdClientUsersUserId(ctx context.Context, clientId int, userId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClientsClientIdClientUsersUserIdRequest(c.Server, clientId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) GetClientsClientIdClientUsersUserId(ctx context.Context, clientId int, userId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientsClientIdClientUsersUserIdRequest(c.Server, clientId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) PutClientsClientIdClientUsersUserIdWithBody(ctx context.Context, clientId int, userId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutClientsClientIdClientUsersUserIdRequestWithBody(c.Server, clientId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) PutClientsClientIdClientUsersUserId(ctx context.Context, clientId int, userId int, body PutClientsClientIdClientUsersUserIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutClientsClientIdClientUsersUserIdRequest(c.Server, clientId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) GetClientsClientIdTokens(ctx context.Context, clientId int, params *GetClientsClientIdTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientsClientIdTokensRequest(c.Server, clientId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) PostClientsClientIdTokensWithBody(ctx context.Context, clientId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClientsClientIdTokensRequestWithBody(c.Server, clientId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) PostClientsClientIdTokens(ctx context.Context, clientId int, body PostClientsClientIdTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClientsClientIdTokensRequest(c.Server, clientId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) DeleteClientsClientIdTokensTokenId(ctx context.Context, clientId int, tokenId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClientsClientIdTokensTokenIdRequest(c.Server, clientId, tokenId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) GetClientsClientIdTokensTokenId(ctx context.Context, clientId int, tokenId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientsClientIdTokensTokenIdRequest(c.Server, clientId, tokenId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) GetUsers(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) GetUsersUserId(ctx context.Context, userId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersUserIdRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) PatchUsersUserIdWithBody(ctx context.Context, userId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUsersUserIdRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) PatchUsersUserId(ctx context.Context, userId int, body PatchUsersUserIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUsersUserIdRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) PutUsersUserIdEmailWithBody(ctx context.Context, userId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutUsersUserIdEmailRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) PutUsersUserIdEmail(ctx context.Context, userId int, body PutUsersUserIdEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutUsersUserIdEmailRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) PutUsersUserIdPasswordWithBody(ctx context.Context, userId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutUsersUserIdPasswordRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) PutUsersUserIdPassword(ctx context.Context, userId int, body PutUsersUserIdPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutUsersUserIdPasswordRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetActivityLogLoginsRequest generates requests for GetActivityLogLogins
func NewGetActivityLogLoginsRequest(server string, params *GetActivityLogLoginsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activity_log/logins")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAuthJwtClientsClientIdLoginRequest generates requests for GetAuthJwtClientsClientIdLogin
func NewGetAuthJwtClientsClientIdLoginRequest(server string, clientId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/jwt/clients/%s/login", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAuthJwtLoginRequest calls the generic PostAuthJwtLogin builder with application/json body
func NewPostAuthJwtLoginRequest(server string, body PostAuthJwtLoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuthJwtLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewPostAuthJwtLoginRequestWithBody generates requests for PostAuthJwtLogin with any type of body
func NewPostAuthJwtLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/jwt/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostAuthJwtRefreshRequest calls the generic PostAuthJwtRefresh builder with application/json body
func NewPostAuthJwtRefreshRequest(server string, body PostAuthJwtRefreshJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuthJwtRefreshRequestWithBody(server, "application/json", bodyReader)
}

// NewPostAuthJwtRefreshRequestWithBody generates requests for PostAuthJwtRefresh with any type of body
func NewPostAuthJwtRefreshRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/jwt/refresh")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostAuthPasswordForgotRequest calls the generic PostAuthPasswordForgot builder with application/json body
func NewPostAuthPasswordForgotRequest(server string, body PostAuthPasswordForgotJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuthPasswordForgotRequestWithBody(server, "application/json", bodyReader)
}

// NewPostAuthPasswordForgotRequestWithBody generates requests for PostAuthPasswordForgot with any type of body
func NewPostAuthPasswordForgotRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/password/forgot")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostClientsCreateRequest calls the generic PostClientsCreate builder with application/json body
func NewPostClientsCreateRequest(server string, body PostClientsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostClientsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewPostClientsCreateRequestWithBody generates requests for PostClientsCreate with any type of body
func NewPostClientsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clients/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostClientsInviteUserRequest calls the generic PostClientsInviteUser builder with application/json body
func NewPostClientsInviteUserRequest(server string, body PostClientsInviteUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostClientsInviteUserRequestWithBody(server, "application/json", bodyReader)
}

// NewPostClientsInviteUserRequestWithBody generates requests for PostClientsInviteUser with any type of body
func NewPostClientsInviteUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clients/invite_user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetClientsMeRequest generates requests for GetClientsMe
func NewGetClientsMeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clients/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteClientsClientIdClientUsersUserIdRequest generates requests for DeleteClientsClientIdClientUsersUserId
func NewDeleteClientsClientIdClientUsersUserIdRequest(server string, clientId int, userId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clients/%s/client-users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClientsClientIdClientUsersUserIdRequest generates requests for GetClientsClientIdClientUsersUserId
func NewGetClientsClientIdClientUsersUserIdRequest(server string, clientId int, userId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clients/%s/client-users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutClientsClientIdClientUsersUserIdRequest calls the generic PutClientsClientIdClientUsersUserId builder with application/json body
func NewPutClientsClientIdClientUsersUserIdRequest(server string, clientId int, userId int, body PutClientsClientIdClientUsersUserIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutClientsClientIdClientUsersUserIdRequestWithBody(server, clientId, userId, "application/json", bodyReader)
}

// NewPutClientsClientIdClientUsersUserIdRequestWithBody generates requests for PutClientsClientIdClientUsersUserId with any type of body
func NewPutClientsClientIdClientUsersUserIdRequestWithBody(server string, clientId int, userId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clients/%s/client-users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetClientsClientIdTokensRequest generates requests for GetClientsClientIdTokens
func NewGetClientsClientIdTokensRequest(server string, clientId int, params *GetClientsClientIdTokensParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clients/%s/tokens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Role != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "role", runtime.ParamLocationQuery, *params.Role); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IssuedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "issued_by", runtime.ParamLocationQuery, *params.IssuedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NotIssuedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "not_issued_by", runtime.ParamLocationQuery, *params.NotIssuedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Deleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted", runtime.ParamLocationQuery, *params.Deleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostClientsClientIdTokensRequest calls the generic PostClientsClientIdTokens builder with application/json body
func NewPostClientsClientIdTokensRequest(server string, clientId int, body PostClientsClientIdTokensJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostClientsClientIdTokensRequestWithBody(server, clientId, "application/json", bodyReader)
}

// NewPostClientsClientIdTokensRequestWithBody generates requests for PostClientsClientIdTokens with any type of body
func NewPostClientsClientIdTokensRequestWithBody(server string, clientId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clients/%s/tokens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteClientsClientIdTokensTokenIdRequest generates requests for DeleteClientsClientIdTokensTokenId
func NewDeleteClientsClientIdTokensTokenIdRequest(server string, clientId int, tokenId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tokenId", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clients/%s/tokens/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClientsClientIdTokensTokenIdRequest generates requests for GetClientsClientIdTokensTokenId
func NewGetClientsClientIdTokensTokenIdRequest(server string, clientId int, tokenId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tokenId", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clients/%s/tokens/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersRequest generates requests for GetUsers
func NewGetUsersRequest(server string, params *GetUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersUserIdRequest generates requests for GetUsersUserId
func NewGetUsersUserIdRequest(server string, userId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchUsersUserIdRequest calls the generic PatchUsersUserId builder with application/json body
func NewPatchUsersUserIdRequest(server string, userId int, body PatchUsersUserIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchUsersUserIdRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewPatchUsersUserIdRequestWithBody generates requests for PatchUsersUserId with any type of body
func NewPatchUsersUserIdRequestWithBody(server string, userId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutUsersUserIdEmailRequest calls the generic PutUsersUserIdEmail builder with application/json body
func NewPutUsersUserIdEmailRequest(server string, userId int, body PutUsersUserIdEmailJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutUsersUserIdEmailRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewPutUsersUserIdEmailRequestWithBody generates requests for PutUsersUserIdEmail with any type of body
func NewPutUsersUserIdEmailRequestWithBody(server string, userId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/email", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutUsersUserIdPasswordRequest calls the generic PutUsersUserIdPassword builder with application/json body
func NewPutUsersUserIdPasswordRequest(server string, userId int, body PutUsersUserIdPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutUsersUserIdPasswordRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewPutUsersUserIdPasswordRequestWithBody generates requests for PutUsersUserIdPassword with any type of body
func NewPutUsersUserIdPasswordRequestWithBody(server string, userId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/password", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *ClientSDK) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *ClientSDK) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetActivityLogLoginsWithResponse request
	GetActivityLogLoginsWithResponse(ctx context.Context, params *GetActivityLogLoginsParams, reqEditors ...RequestEditorFn) (*GetActivityLogLoginsResponse, error)

	// GetAuthJwtClientsClientIdLoginWithResponse request
	GetAuthJwtClientsClientIdLoginWithResponse(ctx context.Context, clientId int, reqEditors ...RequestEditorFn) (*GetAuthJwtClientsClientIdLoginResponse, error)

	// PostAuthJwtLoginWithBodyWithResponse request with any body
	PostAuthJwtLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthJwtLoginResponse, error)

	PostAuthJwtLoginWithResponse(ctx context.Context, body PostAuthJwtLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthJwtLoginResponse, error)

	// PostAuthJwtRefreshWithBodyWithResponse request with any body
	PostAuthJwtRefreshWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthJwtRefreshResponse, error)

	PostAuthJwtRefreshWithResponse(ctx context.Context, body PostAuthJwtRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthJwtRefreshResponse, error)

	// PostAuthPasswordForgotWithBodyWithResponse request with any body
	PostAuthPasswordForgotWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthPasswordForgotResponse, error)

	PostAuthPasswordForgotWithResponse(ctx context.Context, body PostAuthPasswordForgotJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthPasswordForgotResponse, error)

	// PostClientsCreateWithBodyWithResponse request with any body
	PostClientsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClientsCreateResponse, error)

	PostClientsCreateWithResponse(ctx context.Context, body PostClientsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClientsCreateResponse, error)

	// PostClientsInviteUserWithBodyWithResponse request with any body
	PostClientsInviteUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClientsInviteUserResponse, error)

	PostClientsInviteUserWithResponse(ctx context.Context, body PostClientsInviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClientsInviteUserResponse, error)

	// GetClientsMeWithResponse request
	GetClientsMeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClientsMeResponse, error)

	// DeleteClientsClientIdClientUsersUserIdWithResponse request
	DeleteClientsClientIdClientUsersUserIdWithResponse(ctx context.Context, clientId int, userId int, reqEditors ...RequestEditorFn) (*DeleteClientsClientIdClientUsersUserIdResponse, error)

	// GetClientsClientIdClientUsersUserIdWithResponse request
	GetClientsClientIdClientUsersUserIdWithResponse(ctx context.Context, clientId int, userId int, reqEditors ...RequestEditorFn) (*GetClientsClientIdClientUsersUserIdResponse, error)

	// PutClientsClientIdClientUsersUserIdWithBodyWithResponse request with any body
	PutClientsClientIdClientUsersUserIdWithBodyWithResponse(ctx context.Context, clientId int, userId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutClientsClientIdClientUsersUserIdResponse, error)

	PutClientsClientIdClientUsersUserIdWithResponse(ctx context.Context, clientId int, userId int, body PutClientsClientIdClientUsersUserIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutClientsClientIdClientUsersUserIdResponse, error)

	// GetClientsClientIdTokensWithResponse request
	GetClientsClientIdTokensWithResponse(ctx context.Context, clientId int, params *GetClientsClientIdTokensParams, reqEditors ...RequestEditorFn) (*GetClientsClientIdTokensResponse, error)

	// PostClientsClientIdTokensWithBodyWithResponse request with any body
	PostClientsClientIdTokensWithBodyWithResponse(ctx context.Context, clientId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClientsClientIdTokensResponse, error)

	PostClientsClientIdTokensWithResponse(ctx context.Context, clientId int, body PostClientsClientIdTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClientsClientIdTokensResponse, error)

	// DeleteClientsClientIdTokensTokenIdWithResponse request
	DeleteClientsClientIdTokensTokenIdWithResponse(ctx context.Context, clientId int, tokenId int, reqEditors ...RequestEditorFn) (*DeleteClientsClientIdTokensTokenIdResponse, error)

	// GetClientsClientIdTokensTokenIdWithResponse request
	GetClientsClientIdTokensTokenIdWithResponse(ctx context.Context, clientId int, tokenId int, reqEditors ...RequestEditorFn) (*GetClientsClientIdTokensTokenIdResponse, error)

	// GetUsersWithResponse request
	GetUsersWithResponse(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*GetUsersResponse, error)

	// GetUsersUserIdWithResponse request
	GetUsersUserIdWithResponse(ctx context.Context, userId int, reqEditors ...RequestEditorFn) (*GetUsersUserIdResponse, error)

	// PatchUsersUserIdWithBodyWithResponse request with any body
	PatchUsersUserIdWithBodyWithResponse(ctx context.Context, userId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUsersUserIdResponse, error)

	PatchUsersUserIdWithResponse(ctx context.Context, userId int, body PatchUsersUserIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUsersUserIdResponse, error)

	// PutUsersUserIdEmailWithBodyWithResponse request with any body
	PutUsersUserIdEmailWithBodyWithResponse(ctx context.Context, userId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutUsersUserIdEmailResponse, error)

	PutUsersUserIdEmailWithResponse(ctx context.Context, userId int, body PutUsersUserIdEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*PutUsersUserIdEmailResponse, error)

	// PutUsersUserIdPasswordWithBodyWithResponse request with any body
	PutUsersUserIdPasswordWithBodyWithResponse(ctx context.Context, userId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutUsersUserIdPasswordResponse, error)

	PutUsersUserIdPasswordWithResponse(ctx context.Context, userId int, body PutUsersUserIdPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*PutUsersUserIdPasswordResponse, error)
}

type GetActivityLogLoginsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count Total number of users
		Count *float32 `json:"count,omitempty"`

		// Next URL to the next users slice
		Next *string `json:"next,omitempty"`

		// Previous URL to the previous users slice
		Previous *string      `json:"previous,omitempty"`
		Result   *interface{} `json:"result,omitempty"`
	}
	JSON400 *struct {
		union json.RawMessage
	}
}
type GetActivityLogLogins4000 struct {
	// Errors This object contains error descriptions per field from your request.
	Errors *map[string][]string `json:"errors,omitempty"`
}
type GetActivityLogLogins4001 struct {
	// Message This message describes error if json schema from your request is invalid.
	Message *string `json:"message,omitempty"`
}

// Status returns HTTPResponse.Status
func (r GetActivityLogLoginsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActivityLogLoginsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthJwtClientsClientIdLoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Access Use this token to access API.
		Access *string `json:"access,omitempty"`

		// Refresh Use this token to refresh the access token via
		// [`/auth/jwt/refresh`](#tag/Account/paths/~1auth~1jwt~1refresh/post) method.
		Refresh *string `json:"refresh,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAuthJwtClientsClientIdLoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthJwtClientsClientIdLoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthJwtLoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Access Use this token to access API.
		Access *string `json:"access,omitempty"`

		// Refresh Use this token to refresh the access token via
		// [`/auth/jwt/refresh`](#tag/Account/paths/~1auth~1jwt~1refresh/post) method.
		Refresh *string `json:"refresh,omitempty"`
	}
	JSON400 *struct {
		union json.RawMessage
	}
}
type PostAuthJwtLogin4000 struct {
	// Errors This object contains error descriptions per field from your request.
	Errors *map[string][]string `json:"errors,omitempty"`
}
type PostAuthJwtLogin4001 struct {
	// Message This message describes error if json schema from your request is invalid.
	Message *string `json:"message,omitempty"`
}
type PostAuthJwtLogin4002 struct {
	// Errors Username or password is incorrect. Check you username and password and try again.
	Errors *struct {
		Errors *[]PostAuthJwtLogin4002ErrorsErrors `json:"errors,omitempty"`
	} `json:"errors,omitempty"`
}
type PostAuthJwtLogin4002ErrorsErrors string

// Status returns HTTPResponse.Status
func (r PostAuthJwtLoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthJwtLoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthJwtRefreshResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Access Use this token to access API.
		Access *string `json:"access,omitempty"`

		// Refresh Use this token to refresh the access token via
		// [`/auth/jwt/refresh`](#tag/Account/paths/~1auth~1jwt~1refresh/post) method.
		Refresh *string `json:"refresh,omitempty"`
	}
	JSON400 *struct {
		union json.RawMessage
	}
}
type PostAuthJwtRefresh4000 struct {
	// Errors This object contains error descriptions per field from your request.
	Errors *map[string][]string `json:"errors,omitempty"`
}

// Status returns HTTPResponse.Status
func (r PostAuthJwtRefreshResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthJwtRefreshResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthPasswordForgotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		union json.RawMessage
	}
}
type PostAuthPasswordForgot4000 struct {
	// Errors This object contains error descriptions per field from your request.
	Errors *map[string][]string `json:"errors,omitempty"`
}

// Status returns HTTPResponse.Status
func (r PostAuthPasswordForgotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthPasswordForgotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostClientsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Company The company name.
		Company string `json:"company"`

		// Id The ID of the created account.
		Id *int `json:"id,omitempty"`
	}
	JSON400 *struct {
		union json.RawMessage
	}
}
type PostClientsCreate4000 struct {
	// Errors This object contains error descriptions per field from your request.
	Errors *map[string][]string `json:"errors,omitempty"`
}

// Status returns HTTPResponse.Status
func (r PostClientsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostClientsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostClientsInviteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Status Status of the invitation.
		Status *string `json:"status,omitempty"`

		// UserId Invited user ID.
		UserId *int `json:"user_id,omitempty"`
	}
	JSON400 *struct {
		union json.RawMessage
	}
}
type PostClientsInviteUser4000 struct {
	// Errors This object contains error descriptions per field from your request.
	Errors *map[string][]string `json:"errors,omitempty"`
}
// type PostClientsInviteUser4001 = []PostClientsInviteUser4001
// type PostClientsInviteUser4001 string
// type PostClientsInviteUser4002 = []PostClientsInviteUser4002
// type PostClientsInviteUser4002 string

// Status returns HTTPResponse.Status
func (r PostClientsInviteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostClientsInviteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientsMeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// BillType System field. Billing type of the account.
		BillType *string `json:"bill_type,omitempty"`

		// Capabilities System field. List of services available for the account.
		Capabilities *[]GetClientsMe200Capabilities `json:"capabilities,omitempty"`

		// CompanyName The company name.
		CompanyName *string `json:"companyName,omitempty"`

		// CountryCode System field. The company country (ISO 3166-1 alpha-2 format).
		CountryCode *string `json:"country_code,omitempty"`

		// CurrentUser ID of the current user.
		CurrentUser *int `json:"currentUser,omitempty"`

		// CustomId The account custom ID.
		CustomId *string `json:"custom_id"`

		// Deleted The field shows the status of the account:
		//   - `true` – the account has been deleted
		//   - `false` – the account is not deleted
		Deleted *bool `json:"deleted,omitempty"`

		// Email The account email.
		Email *openapi_types.Email `json:"email,omitempty"`

		// EntryBaseDomain System field. Control panel domain.
		EntryBaseDomain *string `json:"entryBaseDomain"`

		// FreeFeatures An object of arrays which contains information about free features available for the requested account.
		FreeFeatures *struct {
			CDN *[]struct {
				// CreateDate Date and time when the feature was activated (ISO 8086/RFC 3339 format).
				CreateDate *string `json:"create_date,omitempty"`

				// FeatureId Feature ID.
				FeatureId *int `json:"feature_id,omitempty"`

				// FreeFeatureId Internal feature activation ID.
				FreeFeatureId *int `json:"free_feature_id,omitempty"`

				// Name Name of the feature.
				Name    *string      `json:"name,omitempty"`
				Service *interface{} `json:"service,omitempty"`
			} `json:"CDN,omitempty"`
			CLOUD *[]struct {
				// CreateDate Date and time when the feature was activated (ISO 8086/RFC 3339 format).
				CreateDate *string `json:"create_date,omitempty"`

				// FeatureId Feature ID.
				FeatureId *int `json:"feature_id,omitempty"`

				// FreeFeatureId Internal feature activation ID.
				FreeFeatureId *int `json:"free_feature_id,omitempty"`

				// Name Name of the feature.
				Name    *string      `json:"name,omitempty"`
				Service *interface{} `json:"service,omitempty"`
			} `json:"CLOUD,omitempty"`
			DDOS *[]struct {
				// CreateDate Date and time when the feature was activated (ISO 8086/RFC 3339 format).
				CreateDate *string `json:"create_date,omitempty"`

				// FeatureId Feature ID.
				FeatureId *int `json:"feature_id,omitempty"`

				// FreeFeatureId Internal feature activation ID.
				FreeFeatureId *int `json:"free_feature_id,omitempty"`

				// Name Name of the feature.
				Name    *string      `json:"name,omitempty"`
				Service *interface{} `json:"service,omitempty"`
			} `json:"DDOS,omitempty"`
			DNS *[]struct {
				// CreateDate Date and time when the feature was activated (ISO 8086/RFC 3339 format).
				CreateDate *string `json:"create_date,omitempty"`

				// FeatureId Feature ID.
				FeatureId *int `json:"feature_id,omitempty"`

				// FreeFeatureId Internal feature activation ID.
				FreeFeatureId *int `json:"free_feature_id,omitempty"`

				// Name Name of the feature.
				Name    *string      `json:"name,omitempty"`
				Service *interface{} `json:"service,omitempty"`
			} `json:"DNS,omitempty"`
			STORAGE *[]struct {
				// CreateDate Date and time when the feature was activated (ISO 8086/RFC 3339 format).
				CreateDate *string `json:"create_date,omitempty"`

				// FeatureId Feature ID.
				FeatureId *int `json:"feature_id,omitempty"`

				// FreeFeatureId Internal feature activation ID.
				FreeFeatureId *int `json:"free_feature_id,omitempty"`

				// Name Name of the feature.
				Name    *string      `json:"name,omitempty"`
				Service *interface{} `json:"service,omitempty"`
			} `json:"STORAGE,omitempty"`
			STREAMING *[]struct {
				// CreateDate Date and time when the feature was activated (ISO 8086/RFC 3339 format).
				CreateDate *string `json:"create_date,omitempty"`

				// FeatureId Feature ID.
				FeatureId *int `json:"feature_id,omitempty"`

				// FreeFeatureId Internal feature activation ID.
				FreeFeatureId *int `json:"free_feature_id,omitempty"`

				// Name Name of the feature.
				Name    *string      `json:"name,omitempty"`
				Service *interface{} `json:"service,omitempty"`
			} `json:"STREAMING,omitempty"`
		} `json:"freeFeatures,omitempty"`

		// HasActiveAdmin System field.
		HasActiveAdmin *bool `json:"has_active_admin,omitempty"`

		// Id The account ID.
		Id *int `json:"id,omitempty"`

		// IsTest System field:
		// - `true` — a test account;
		// - `false` — a production account.
		IsTest *bool `json:"is_test,omitempty"`

		// Name Name of a user who registered the requested account.
		Name *string `json:"name"`

		// PaidFeatures An object of arrays which contains information about paid features available for the requested account.
		PaidFeatures *struct {
			CDN *[]struct {
				// CreateDate Date and time when the feature was activated (ISO 8086/RFC 3339 format).
				CreateDate *string `json:"create_date,omitempty"`

				// FeatureId Feature ID.
				FeatureId *int `json:"feature_id,omitempty"`

				// Name Name of the feature.
				Name *string `json:"name,omitempty"`

				// PaidFeatureId Internal feature activation ID.
				PaidFeatureId *int         `json:"paid_feature_id,omitempty"`
				Service       *interface{} `json:"service,omitempty"`
			} `json:"CDN,omitempty"`
			CLOUD *[]struct {
				// CreateDate Date and time when the feature was activated (ISO 8086/RFC 3339 format).
				CreateDate *string `json:"create_date,omitempty"`

				// FeatureId Feature ID.
				FeatureId *int `json:"feature_id,omitempty"`

				// Name Name of the feature.
				Name *string `json:"name,omitempty"`

				// PaidFeatureId Internal feature activation ID.
				PaidFeatureId *int         `json:"paid_feature_id,omitempty"`
				Service       *interface{} `json:"service,omitempty"`
			} `json:"CLOUD,omitempty"`
			DDOS *[]struct {
				// CreateDate Date and time when the feature was activated (ISO 8086/RFC 3339 format).
				CreateDate *string `json:"create_date,omitempty"`

				// FeatureId Feature ID.
				FeatureId *int `json:"feature_id,omitempty"`

				// Name Name of the feature.
				Name *string `json:"name,omitempty"`

				// PaidFeatureId Internal feature activation ID.
				PaidFeatureId *int         `json:"paid_feature_id,omitempty"`
				Service       *interface{} `json:"service,omitempty"`
			} `json:"DDOS,omitempty"`
			DNS *[]struct {
				// CreateDate Date and time when the feature was activated (ISO 8086/RFC 3339 format).
				CreateDate *string `json:"create_date,omitempty"`

				// FeatureId Feature ID.
				FeatureId *int `json:"feature_id,omitempty"`

				// Name Name of the feature.
				Name *string `json:"name,omitempty"`

				// PaidFeatureId Internal feature activation ID.
				PaidFeatureId *int         `json:"paid_feature_id,omitempty"`
				Service       *interface{} `json:"service,omitempty"`
			} `json:"DNS,omitempty"`
			STORAGE *[]struct {
				// CreateDate Date and time when the feature was activated (ISO 8086/RFC 3339 format).
				CreateDate *string `json:"create_date,omitempty"`

				// FeatureId Feature ID.
				FeatureId *int `json:"feature_id,omitempty"`

				// Name Name of the feature.
				Name *string `json:"name,omitempty"`

				// PaidFeatureId Internal feature activation ID.
				PaidFeatureId *int         `json:"paid_feature_id,omitempty"`
				Service       *interface{} `json:"service,omitempty"`
			} `json:"STORAGE,omitempty"`
			STREAMING *[]struct {
				// CreateDate Date and time when the feature was activated (ISO 8086/RFC 3339 format).
				CreateDate *string `json:"create_date,omitempty"`

				// FeatureId Feature ID.
				FeatureId *int `json:"feature_id,omitempty"`

				// Name Name of the feature.
				Name *string `json:"name,omitempty"`

				// PaidFeatureId Internal feature activation ID.
				PaidFeatureId *int         `json:"paid_feature_id,omitempty"`
				Service       *interface{} `json:"service,omitempty"`
			} `json:"STREAMING,omitempty"`
		} `json:"paidFeatures,omitempty"`

		// Phone Phone of a user who registered the requested account.
		Phone *string `json:"phone"`

		// ServiceStatuses An object of arrays which contains information about all services available for the requested account.
		ServiceStatuses *struct {
			CDN *struct {
				// Enabled `true` - service is available in the Control Panel.
				Enabled *bool `json:"enabled,omitempty"`

				// Status Status of the service.
				Status *GetClientsMe200ServiceStatusesCDNStatus `json:"status,omitempty"`
			} `json:"CDN,omitempty"`
			CLOUD *struct {
				// Enabled `true` - service is available in the Control Panel.
				Enabled *bool `json:"enabled,omitempty"`

				// Status Status of the service.
				Status *GetClientsMe200ServiceStatusesCLOUDStatus `json:"status,omitempty"`
			} `json:"CLOUD,omitempty"`
			DDOS *struct {
				// Enabled `true` - service is available in the Control Panel.
				Enabled *bool `json:"enabled,omitempty"`

				// Status Status of the service.
				Status *GetClientsMe200ServiceStatusesDDOSStatus `json:"status,omitempty"`
			} `json:"DDOS,omitempty"`
			DNS *struct {
				// Enabled `true` - service is available in the Control Panel.
				Enabled *bool `json:"enabled,omitempty"`

				// Status Status of the service.
				Status *GetClientsMe200ServiceStatusesDNSStatus `json:"status,omitempty"`
			} `json:"DNS,omitempty"`
			STORAGE *struct {
				// Enabled `true` - service is available in the Control Panel.
				Enabled *bool `json:"enabled,omitempty"`

				// Status Status of the service.
				Status *GetClientsMe200ServiceStatusesSTORAGEStatus `json:"status,omitempty"`
			} `json:"STORAGE,omitempty"`
			STREAMING *struct {
				// Enabled `true` - service is available in the Control Panel.
				Enabled *bool `json:"enabled,omitempty"`

				// Status Status of the service.
				Status *GetClientsMe200ServiceStatusesSTREAMINGStatus `json:"status,omitempty"`
			} `json:"STREAMING,omitempty"`
		} `json:"serviceStatuses,omitempty"`

		// SignupProcess System field. Type of the account registration process.
		SignupProcess *GetClientsMe200SignupProcess `json:"signup_process"`

		// Status Status of the account.
		Status *GetClientsMe200Status `json:"status,omitempty"`

		// Users List of account users.
		Users *[]struct {
			// Activated Email confirmation:
			// - `true` – user confirmed the email;
			// - `false` – user did not confirm the email.
			Activated *bool `json:"activated,omitempty"`

			// AuthTypes System field. List of auth types available for the account.
			AuthTypes *[]GetClientsMe200UsersAuthTypes `json:"auth_types,omitempty"`

			// Client User's  account ID.
			Client *float32 `json:"client,omitempty"`

			// Company User's company.
			Company *string `json:"company,omitempty"`

			// Deleted Deletion flag. If `true` then user was deleted.
			Deleted *bool `json:"deleted,omitempty"`

			// Email User's email address.
			Email *openapi_types.Email `json:"email,omitempty"`

			// Groups User's group in the current account.
			//
			// IAM supports 5 groups:
			//
			//   - Users
			//   - Administrators
			//   - Engineers
			//   - Purge and Prefetch only (API)
			//   - Purge and Prefetch only (API+Web)
			Groups *[]struct {
				// Id Group&#39;s ID: Possible values are: <br> <ul> <li>1 - Administrators <li>2 - Users <li>5 - Engineers <li>3009 - Purge and Prefetch only (API+Web) <li>3022 - Purge and Prefetch only (API)
				Id *int `json:"id,omitempty"`

				// Name Group's name.
				Name *GetClientsMe200UsersGroupsName `json:"name,omitempty"`
			} `json:"groups,omitempty"`

			// Id User's ID.
			Id *int `json:"id,omitempty"`

			// Lang User's language.
			//
			// Defines language of the control panel and email messages.
			Lang *GetClientsMe200UsersLang `json:"lang,omitempty"`

			// Name User's name.
			Name *string `json:"name"`

			// Phone User's phone.
			Phone *string `json:"phone"`

			// Reseller Services provider ID.
			Reseller *int `json:"reseller,omitempty"`

			// SsoAuth SSO authentication flag. If `true` then user can login via SAML SSO.
			SsoAuth *bool `json:"sso_auth,omitempty"`

			// TwoFa Two-step verification:
			//   - `true` – user enabled two-step verification;
			//   - `false` – user disabled two-step verification.
			TwoFa *bool `json:"two_fa,omitempty"`
		} `json:"users,omitempty"`

		// Website The company website.
		Website *string `json:"website,omitempty"`
	}
}
type GetClientsMe200Capabilities string
type GetClientsMe200ServiceStatusesCDNStatus string
type GetClientsMe200ServiceStatusesCLOUDStatus string
type GetClientsMe200ServiceStatusesDDOSStatus string
type GetClientsMe200ServiceStatusesDNSStatus string
type GetClientsMe200ServiceStatusesSTORAGEStatus string
type GetClientsMe200ServiceStatusesSTREAMINGStatus string
type GetClientsMe200SignupProcess string
type GetClientsMe200Status string
type GetClientsMe200UsersAuthTypes string
type GetClientsMe200UsersGroupsName string
type GetClientsMe200UsersLang string

// Status returns HTTPResponse.Status
func (r GetClientsMeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientsMeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClientsClientIdClientUsersUserIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *struct {
		union json.RawMessage
	}
}
type DeleteClientsClientIdClientUsersUserId4030 = map[string]interface{}
type DeleteClientsClientIdClientUsersUserId4031 struct {
	// Message The specified user has API tokens.
	// Please [delete API tokens](#tag/API-Tokens/paths/~1clients~1{clientId}~1tokens~1{tokenId}/delete) before the user deleting.
	Message *string `json:"message,omitempty"`
}

// Status returns HTTPResponse.Status
func (r DeleteClientsClientIdClientUsersUserIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClientsClientIdClientUsersUserIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientsClientIdClientUsersUserIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		UserRole *struct {
			// Id Group&#39;s ID: Possible values are: <br> <ul> <li>1 - Administrators <li>2 - Users <li>5 - Engineers <li>3009 - Purge and Prefetch only (API+Web) <li>3022 - Purge and Prefetch only (API)
			Id *int `json:"id,omitempty"`

			// Name Group's name.
			Name *GetClientsClientIdClientUsersUserId200UserRoleName `json:"name,omitempty"`
		} `json:"user_role,omitempty"`
	}
}
type GetClientsClientIdClientUsersUserId200UserRoleName string

// Status returns HTTPResponse.Status
func (r GetClientsClientIdClientUsersUserIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientsClientIdClientUsersUserIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutClientsClientIdClientUsersUserIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		// Errors This object contains error descriptions per field from your request.
		Errors *struct {
			// PropertyName Error list for a specific field.
			PropertyName *[]string `json:"property_name,omitempty"`
		} `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PutClientsClientIdClientUsersUserIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutClientsClientIdClientUsersUserIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientsClientIdTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// ClientUser API token role and issuer data.
		ClientUser struct {
			// ClientId Account's ID.
			ClientId *int `json:"client_id,omitempty"`

			// Deleted Deletion flag. If true, then the API token was deleted.
			Deleted *bool `json:"deleted,omitempty"`
			Role    *struct {
				// Id Group&#39;s ID: Possible values are: <br> <ul> <li>1 - Administrators <li>2 - Users <li>5 - Engineers <li>3009 - Purge and Prefetch only (API+Web) <li>3022 - Purge and Prefetch only (API)
				Id *int `json:"id,omitempty"`

				// Name Group's name.
				Name *GetClientsClientIdTokens200ClientUserRoleName `json:"name,omitempty"`
			} `json:"role,omitempty"`

			// UserEmail User's email who issued the API token.
			UserEmail *string `json:"user_email,omitempty"`

			// UserId User's ID who issued the API token.
			UserId *int `json:"user_id,omitempty"`

			// UserName User's name who issued the API token.
			UserName *string `json:"user_name,omitempty"`
		} `json:"client_user"`

		// Created Date when the API token was issued (ISO 8086/RFC 3339 format), UTC.
		Created *string `json:"created,omitempty"`

		// Deleted Deletion flag. If true, then the API token was deleted.
		Deleted *bool `json:"deleted,omitempty"`

		// Description API token description.
		Description *string `json:"description,omitempty"`

		// ExpDate Date when the API token becomes expired (ISO 8086/RFC 3339 format), UTC.
		// If null, then the API token will never expire.
		ExpDate *string `json:"exp_date,omitempty"`

		// Expired Expiration flag. If true, then the API token has expired.
		// When an API token expires it will be automatically deleted.
		Expired *bool `json:"expired,omitempty"`

		// Id API token ID.
		Id *int `json:"id,omitempty"`

		// LastUsage Date when the API token was last used (ISO 8086/RFC 3339 format), UTC.
		LastUsage *string `json:"last_usage,omitempty"`

		// Name API token name.
		Name string `json:"name"`
	}
}
type GetClientsClientIdTokens200ClientUserRoleName string

// Status returns HTTPResponse.Status
func (r GetClientsClientIdTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientsClientIdTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostClientsClientIdTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Token API token.
		// Copy it, because you will not be able to get it again.
		// We do not store tokens. All responsibility for token storage and usage is on the issuer.
		Token *string `json:"token,omitempty"`
	}
	JSON400 *struct {
		union json.RawMessage
	}
}
type PostClientsClientIdTokens4000 struct {
	// Errors The specified role does not exist. Please check the role name.
	Errors *map[string]interface{} `json:"errors,omitempty"`
}
type PostClientsClientIdTokens4001 struct {
	// Errors The specified role is higher than yours. Try using another role.
	Errors *map[string]interface{} `json:"errors,omitempty"`
}

// Status returns HTTPResponse.Status
func (r PostClientsClientIdTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostClientsClientIdTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClientsClientIdTokensTokenIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteClientsClientIdTokensTokenIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClientsClientIdTokensTokenIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientsClientIdTokensTokenIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ClientUser API token role and issuer data.
		ClientUser struct {
			// ClientId Account's ID.
			ClientId *int `json:"client_id,omitempty"`

			// Deleted Deletion flag. If true, then the API token was deleted.
			Deleted *bool `json:"deleted,omitempty"`
			Role    *struct {
				// Id Group&#39;s ID: Possible values are: <br> <ul> <li>1 - Administrators <li>2 - Users <li>5 - Engineers <li>3009 - Purge and Prefetch only (API+Web) <li>3022 - Purge and Prefetch only (API)
				Id *int `json:"id,omitempty"`

				// Name Group's name.
				Name *GetClientsClientIdTokensTokenId200ClientUserRoleName `json:"name,omitempty"`
			} `json:"role,omitempty"`

			// UserEmail User's email who issued the API token.
			UserEmail *string `json:"user_email,omitempty"`

			// UserId User's ID who issued the API token.
			UserId *int `json:"user_id,omitempty"`

			// UserName User's name who issued the API token.
			UserName *string `json:"user_name,omitempty"`
		} `json:"client_user"`

		// Created Date when the API token was issued (ISO 8086/RFC 3339 format), UTC.
		Created *string `json:"created,omitempty"`

		// Deleted Deletion flag. If true, then the API token was deleted.
		Deleted *bool `json:"deleted,omitempty"`

		// Description API token description.
		Description *string `json:"description,omitempty"`

		// ExpDate Date when the API token becomes expired (ISO 8086/RFC 3339 format), UTC.
		// If null, then the API token will never expire.
		ExpDate *string `json:"exp_date,omitempty"`

		// Expired Expiration flag. If true, then the API token has expired.
		// When an API token expires it will be automatically deleted.
		Expired *bool `json:"expired,omitempty"`

		// Id API token ID.
		Id *int `json:"id,omitempty"`

		// LastUsage Date when the API token was last used (ISO 8086/RFC 3339 format), UTC.
		LastUsage *string `json:"last_usage,omitempty"`

		// Name API token name.
		Name string `json:"name"`
	}
}
type GetClientsClientIdTokensTokenId200ClientUserRoleName string

// Status returns HTTPResponse.Status
func (r GetClientsClientIdTokensTokenIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientsClientIdTokensTokenIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
}
type GetUsers2000 = []interface{}
type GetUsers2001 struct {
	// Count Total number of users
	Count *float32 `json:"count,omitempty"`

	// Next URL to the next users slice
	Next *string `json:"next,omitempty"`

	// Previous URL to the previous users slice
	Previous *string      `json:"previous,omitempty"`
	Result   *interface{} `json:"result,omitempty"`
}

// Status returns HTTPResponse.Status
func (r GetUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersUserIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Activated Email confirmation:
		// - `true` – user confirmed the email;
		// - `false` – user did not confirm the email.
		Activated *bool `json:"activated,omitempty"`

		// AuthTypes System field. List of auth types available for the account.
		AuthTypes *[]GetUsersUserId200AuthTypes `json:"auth_types,omitempty"`

		// Client User's  account ID.
		Client *float32 `json:"client,omitempty"`

		// ClientAndRoles List of user's clients. User can access to one or more clients.
		ClientAndRoles *[]struct {
			ClientCompanyName string `json:"client_company_name"`
			ClientId          int    `json:"client_id"`

			// UserId User's ID.
			UserId int `json:"user_id"`

			// UserRoles User role in this client.
			UserRoles []string `json:"user_roles"`
		} `json:"client_and_roles,omitempty"`

		// Company User's company.
		Company *string `json:"company,omitempty"`

		// Deleted Deletion flag. If `true` then user was deleted.
		Deleted *bool `json:"deleted,omitempty"`

		// Email User's email address.
		Email *openapi_types.Email `json:"email,omitempty"`

		// Groups User's group in the current account.
		//
		// IAM supports 5 groups:
		//
		//   - Users
		//   - Administrators
		//   - Engineers
		//   - Purge and Prefetch only (API)
		//   - Purge and Prefetch only (API+Web)
		Groups *[]struct {
			// Id Group&#39;s ID: Possible values are: <br> <ul> <li>1 - Administrators <li>2 - Users <li>5 - Engineers <li>3009 - Purge and Prefetch only (API+Web) <li>3022 - Purge and Prefetch only (API)
			Id *int `json:"id,omitempty"`

			// Name Group's name.
			Name *GetUsersUserId200GroupsName `json:"name,omitempty"`
		} `json:"groups,omitempty"`

		// Id User's ID.
		Id *int `json:"id,omitempty"`

		// IsActive User activity flag.
		IsActive *bool `json:"is_active,omitempty"`

		// Lang User's language.
		//
		// Defines language of the control panel and email messages.
		Lang *GetUsersUserId200Lang `json:"lang,omitempty"`

		// Name User's name.
		Name *string `json:"name"`

		// Phone User's phone.
		Phone *string `json:"phone"`

		// Reseller Services provider ID.
		Reseller *int `json:"reseller,omitempty"`

		// SsoAuth SSO authentication flag. If `true` then user can login via SAML SSO.
		SsoAuth *bool `json:"sso_auth,omitempty"`

		// TwoFa Two-step verification:
		//   - `true` – user enabled two-step verification;
		//   - `false` – user disabled two-step verification.
		TwoFa *bool `json:"two_fa,omitempty"`

		// UserType User's type.
		UserType *GetUsersUserId200UserType `json:"user_type,omitempty"`
	}
}
type GetUsersUserId200AuthTypes string
type GetUsersUserId200GroupsName string
type GetUsersUserId200Lang string
type GetUsersUserId200UserType string

// Status returns HTTPResponse.Status
func (r GetUsersUserIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersUserIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchUsersUserIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Activated Email confirmation:
		// - `true` – user confirmed the email;
		// - `false` – user did not confirm the email.
		Activated *bool `json:"activated,omitempty"`

		// AuthTypes System field. List of auth types available for the account.
		AuthTypes *[]PatchUsersUserId200AuthTypes `json:"auth_types,omitempty"`

		// Client User's  account ID.
		Client *float32 `json:"client,omitempty"`

		// ClientAndRoles List of user's clients. User can access to one or more clients.
		ClientAndRoles *[]struct {
			ClientCompanyName string `json:"client_company_name"`
			ClientId          int    `json:"client_id"`

			// UserId User's ID.
			UserId int `json:"user_id"`

			// UserRoles User role in this client.
			UserRoles []string `json:"user_roles"`
		} `json:"client_and_roles,omitempty"`

		// Company User's company.
		Company *string `json:"company,omitempty"`

		// Deleted Deletion flag. If `true` then user was deleted.
		Deleted *bool `json:"deleted,omitempty"`

		// Email User's email address.
		Email *openapi_types.Email `json:"email,omitempty"`

		// Groups User's group in the current account.
		//
		// IAM supports 5 groups:
		//
		//   - Users
		//   - Administrators
		//   - Engineers
		//   - Purge and Prefetch only (API)
		//   - Purge and Prefetch only (API+Web)
		Groups *[]struct {
			// Id Group&#39;s ID: Possible values are: <br> <ul> <li>1 - Administrators <li>2 - Users <li>5 - Engineers <li>3009 - Purge and Prefetch only (API+Web) <li>3022 - Purge and Prefetch only (API)
			Id *int `json:"id,omitempty"`

			// Name Group's name.
			Name *PatchUsersUserId200GroupsName `json:"name,omitempty"`
		} `json:"groups,omitempty"`

		// Id User's ID.
		Id *int `json:"id,omitempty"`

		// IsActive User activity flag.
		IsActive *bool `json:"is_active,omitempty"`

		// Lang User's language.
		//
		// Defines language of the control panel and email messages.
		Lang *PatchUsersUserId200Lang `json:"lang,omitempty"`

		// Name User's name.
		Name *string `json:"name"`

		// Phone User's phone.
		Phone *string `json:"phone"`

		// Reseller Services provider ID.
		Reseller *int `json:"reseller,omitempty"`

		// SsoAuth SSO authentication flag. If `true` then user can login via SAML SSO.
		SsoAuth *bool `json:"sso_auth,omitempty"`

		// TwoFa Two-step verification:
		//   - `true` – user enabled two-step verification;
		//   - `false` – user disabled two-step verification.
		TwoFa *bool `json:"two_fa,omitempty"`

		// UserType User's type.
		UserType *PatchUsersUserId200UserType `json:"user_type,omitempty"`
	}
	JSON400 *struct {
		union json.RawMessage
	}
}
type PatchUsersUserId200AuthTypes string
type PatchUsersUserId200GroupsName string
type PatchUsersUserId200Lang string
type PatchUsersUserId200UserType string
type PatchUsersUserId4000 struct {
	// Errors This object contains error descriptions per field from your request.
	Errors *map[string][]string `json:"errors,omitempty"`
}
type PatchUsersUserId4001 struct {
	// Message This message describes error if json schema from your request is invalid.
	Message *string `json:"message,omitempty"`
}

// Status returns HTTPResponse.Status
func (r PatchUsersUserIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchUsersUserIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutUsersUserIdEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NewEmail User's new email.
		NewEmail *string `json:"new_email,omitempty"`
	}
	JSON400 *struct {
		union json.RawMessage
	}
}
type PutUsersUserIdEmail4000 = []struct {
	Errors *struct {
		// NewEmail Same email address.
		NewEmail *string `json:"new_email,omitempty"`
	} `json:"errors,omitempty"`
}
type PutUsersUserIdEmail4001 = []struct {
	Errors *struct {
		// NewEmail Enter a valid email address
		NewEmail *string `json:"new_email,omitempty"`
	} `json:"errors,omitempty"`
}
type PutUsersUserIdEmail4002 = []struct {
	Errors *struct {
		// NewEmail Client with email {new_email} already exists.
		NewEmail *string `json:"new_email,omitempty"`
	} `json:"errors,omitempty"`
}
type PutUsersUserIdEmail4003 = []struct {
	Errors *struct {
		// Password Password is incorrect.
		Password *string `json:"password,omitempty"`
	} `json:"errors,omitempty"`
}

// Status returns HTTPResponse.Status
func (r PutUsersUserIdEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutUsersUserIdEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutUsersUserIdPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Access Use this token to access API.
		Access *string `json:"access,omitempty"`

		// Refresh Use this token to refresh the access token via
		// [`/auth/jwt/refresh`](#tag/Account/paths/~1auth~1jwt~1refresh/post) method.
		Refresh *string `json:"refresh,omitempty"`
	}
	JSON400 *struct {
		union json.RawMessage
	}
}
type PutUsersUserIdPassword4000 struct {
	// Errors This object contains error descriptions per field from your request.
	Errors *map[string][]string `json:"errors,omitempty"`
}

// Status returns HTTPResponse.Status
func (r PutUsersUserIdPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutUsersUserIdPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetActivityLogLoginsWithResponse request returning *GetActivityLogLoginsResponse
func (c *ClientWithResponses) GetActivityLogLoginsWithResponse(ctx context.Context, params *GetActivityLogLoginsParams, reqEditors ...RequestEditorFn) (*GetActivityLogLoginsResponse, error) {
	rsp, err := c.GetActivityLogLogins(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActivityLogLoginsResponse(rsp)
}

// GetAuthJwtClientsClientIdLoginWithResponse request returning *GetAuthJwtClientsClientIdLoginResponse
func (c *ClientWithResponses) GetAuthJwtClientsClientIdLoginWithResponse(ctx context.Context, clientId int, reqEditors ...RequestEditorFn) (*GetAuthJwtClientsClientIdLoginResponse, error) {
	rsp, err := c.GetAuthJwtClientsClientIdLogin(ctx, clientId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthJwtClientsClientIdLoginResponse(rsp)
}

// PostAuthJwtLoginWithBodyWithResponse request with arbitrary body returning *PostAuthJwtLoginResponse
func (c *ClientWithResponses) PostAuthJwtLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthJwtLoginResponse, error) {
	rsp, err := c.PostAuthJwtLoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthJwtLoginResponse(rsp)
}

func (c *ClientWithResponses) PostAuthJwtLoginWithResponse(ctx context.Context, body PostAuthJwtLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthJwtLoginResponse, error) {
	rsp, err := c.PostAuthJwtLogin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthJwtLoginResponse(rsp)
}

// PostAuthJwtRefreshWithBodyWithResponse request with arbitrary body returning *PostAuthJwtRefreshResponse
func (c *ClientWithResponses) PostAuthJwtRefreshWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthJwtRefreshResponse, error) {
	rsp, err := c.PostAuthJwtRefreshWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthJwtRefreshResponse(rsp)
}

func (c *ClientWithResponses) PostAuthJwtRefreshWithResponse(ctx context.Context, body PostAuthJwtRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthJwtRefreshResponse, error) {
	rsp, err := c.PostAuthJwtRefresh(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthJwtRefreshResponse(rsp)
}

// PostAuthPasswordForgotWithBodyWithResponse request with arbitrary body returning *PostAuthPasswordForgotResponse
func (c *ClientWithResponses) PostAuthPasswordForgotWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthPasswordForgotResponse, error) {
	rsp, err := c.PostAuthPasswordForgotWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthPasswordForgotResponse(rsp)
}

func (c *ClientWithResponses) PostAuthPasswordForgotWithResponse(ctx context.Context, body PostAuthPasswordForgotJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthPasswordForgotResponse, error) {
	rsp, err := c.PostAuthPasswordForgot(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthPasswordForgotResponse(rsp)
}

// PostClientsCreateWithBodyWithResponse request with arbitrary body returning *PostClientsCreateResponse
func (c *ClientWithResponses) PostClientsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClientsCreateResponse, error) {
	rsp, err := c.PostClientsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClientsCreateResponse(rsp)
}

func (c *ClientWithResponses) PostClientsCreateWithResponse(ctx context.Context, body PostClientsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClientsCreateResponse, error) {
	rsp, err := c.PostClientsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClientsCreateResponse(rsp)
}

// PostClientsInviteUserWithBodyWithResponse request with arbitrary body returning *PostClientsInviteUserResponse
func (c *ClientWithResponses) PostClientsInviteUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClientsInviteUserResponse, error) {
	rsp, err := c.PostClientsInviteUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClientsInviteUserResponse(rsp)
}

func (c *ClientWithResponses) PostClientsInviteUserWithResponse(ctx context.Context, body PostClientsInviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClientsInviteUserResponse, error) {
	rsp, err := c.PostClientsInviteUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClientsInviteUserResponse(rsp)
}

// GetClientsMeWithResponse request returning *GetClientsMeResponse
func (c *ClientWithResponses) GetClientsMeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClientsMeResponse, error) {
	rsp, err := c.GetClientsMe(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientsMeResponse(rsp)
}

// DeleteClientsClientIdClientUsersUserIdWithResponse request returning *DeleteClientsClientIdClientUsersUserIdResponse
func (c *ClientWithResponses) DeleteClientsClientIdClientUsersUserIdWithResponse(ctx context.Context, clientId int, userId int, reqEditors ...RequestEditorFn) (*DeleteClientsClientIdClientUsersUserIdResponse, error) {
	rsp, err := c.DeleteClientsClientIdClientUsersUserId(ctx, clientId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClientsClientIdClientUsersUserIdResponse(rsp)
}

// GetClientsClientIdClientUsersUserIdWithResponse request returning *GetClientsClientIdClientUsersUserIdResponse
func (c *ClientWithResponses) GetClientsClientIdClientUsersUserIdWithResponse(ctx context.Context, clientId int, userId int, reqEditors ...RequestEditorFn) (*GetClientsClientIdClientUsersUserIdResponse, error) {
	rsp, err := c.GetClientsClientIdClientUsersUserId(ctx, clientId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientsClientIdClientUsersUserIdResponse(rsp)
}

// PutClientsClientIdClientUsersUserIdWithBodyWithResponse request with arbitrary body returning *PutClientsClientIdClientUsersUserIdResponse
func (c *ClientWithResponses) PutClientsClientIdClientUsersUserIdWithBodyWithResponse(ctx context.Context, clientId int, userId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutClientsClientIdClientUsersUserIdResponse, error) {
	rsp, err := c.PutClientsClientIdClientUsersUserIdWithBody(ctx, clientId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutClientsClientIdClientUsersUserIdResponse(rsp)
}

func (c *ClientWithResponses) PutClientsClientIdClientUsersUserIdWithResponse(ctx context.Context, clientId int, userId int, body PutClientsClientIdClientUsersUserIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutClientsClientIdClientUsersUserIdResponse, error) {
	rsp, err := c.PutClientsClientIdClientUsersUserId(ctx, clientId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutClientsClientIdClientUsersUserIdResponse(rsp)
}

// GetClientsClientIdTokensWithResponse request returning *GetClientsClientIdTokensResponse
func (c *ClientWithResponses) GetClientsClientIdTokensWithResponse(ctx context.Context, clientId int, params *GetClientsClientIdTokensParams, reqEditors ...RequestEditorFn) (*GetClientsClientIdTokensResponse, error) {
	rsp, err := c.GetClientsClientIdTokens(ctx, clientId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientsClientIdTokensResponse(rsp)
}

// PostClientsClientIdTokensWithBodyWithResponse request with arbitrary body returning *PostClientsClientIdTokensResponse
func (c *ClientWithResponses) PostClientsClientIdTokensWithBodyWithResponse(ctx context.Context, clientId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClientsClientIdTokensResponse, error) {
	rsp, err := c.PostClientsClientIdTokensWithBody(ctx, clientId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClientsClientIdTokensResponse(rsp)
}

func (c *ClientWithResponses) PostClientsClientIdTokensWithResponse(ctx context.Context, clientId int, body PostClientsClientIdTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClientsClientIdTokensResponse, error) {
	rsp, err := c.PostClientsClientIdTokens(ctx, clientId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClientsClientIdTokensResponse(rsp)
}

// DeleteClientsClientIdTokensTokenIdWithResponse request returning *DeleteClientsClientIdTokensTokenIdResponse
func (c *ClientWithResponses) DeleteClientsClientIdTokensTokenIdWithResponse(ctx context.Context, clientId int, tokenId int, reqEditors ...RequestEditorFn) (*DeleteClientsClientIdTokensTokenIdResponse, error) {
	rsp, err := c.DeleteClientsClientIdTokensTokenId(ctx, clientId, tokenId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClientsClientIdTokensTokenIdResponse(rsp)
}

// GetClientsClientIdTokensTokenIdWithResponse request returning *GetClientsClientIdTokensTokenIdResponse
func (c *ClientWithResponses) GetClientsClientIdTokensTokenIdWithResponse(ctx context.Context, clientId int, tokenId int, reqEditors ...RequestEditorFn) (*GetClientsClientIdTokensTokenIdResponse, error) {
	rsp, err := c.GetClientsClientIdTokensTokenId(ctx, clientId, tokenId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientsClientIdTokensTokenIdResponse(rsp)
}

// GetUsersWithResponse request returning *GetUsersResponse
func (c *ClientWithResponses) GetUsersWithResponse(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*GetUsersResponse, error) {
	rsp, err := c.GetUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersResponse(rsp)
}

// GetUsersUserIdWithResponse request returning *GetUsersUserIdResponse
func (c *ClientWithResponses) GetUsersUserIdWithResponse(ctx context.Context, userId int, reqEditors ...RequestEditorFn) (*GetUsersUserIdResponse, error) {
	rsp, err := c.GetUsersUserId(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersUserIdResponse(rsp)
}

// PatchUsersUserIdWithBodyWithResponse request with arbitrary body returning *PatchUsersUserIdResponse
func (c *ClientWithResponses) PatchUsersUserIdWithBodyWithResponse(ctx context.Context, userId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUsersUserIdResponse, error) {
	rsp, err := c.PatchUsersUserIdWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUsersUserIdResponse(rsp)
}

func (c *ClientWithResponses) PatchUsersUserIdWithResponse(ctx context.Context, userId int, body PatchUsersUserIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUsersUserIdResponse, error) {
	rsp, err := c.PatchUsersUserId(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUsersUserIdResponse(rsp)
}

// PutUsersUserIdEmailWithBodyWithResponse request with arbitrary body returning *PutUsersUserIdEmailResponse
func (c *ClientWithResponses) PutUsersUserIdEmailWithBodyWithResponse(ctx context.Context, userId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutUsersUserIdEmailResponse, error) {
	rsp, err := c.PutUsersUserIdEmailWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutUsersUserIdEmailResponse(rsp)
}

func (c *ClientWithResponses) PutUsersUserIdEmailWithResponse(ctx context.Context, userId int, body PutUsersUserIdEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*PutUsersUserIdEmailResponse, error) {
	rsp, err := c.PutUsersUserIdEmail(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutUsersUserIdEmailResponse(rsp)
}

// PutUsersUserIdPasswordWithBodyWithResponse request with arbitrary body returning *PutUsersUserIdPasswordResponse
func (c *ClientWithResponses) PutUsersUserIdPasswordWithBodyWithResponse(ctx context.Context, userId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutUsersUserIdPasswordResponse, error) {
	rsp, err := c.PutUsersUserIdPasswordWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutUsersUserIdPasswordResponse(rsp)
}

func (c *ClientWithResponses) PutUsersUserIdPasswordWithResponse(ctx context.Context, userId int, body PutUsersUserIdPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*PutUsersUserIdPasswordResponse, error) {
	rsp, err := c.PutUsersUserIdPassword(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutUsersUserIdPasswordResponse(rsp)
}

// ParseGetActivityLogLoginsResponse parses an HTTP response from a GetActivityLogLoginsWithResponse call
func ParseGetActivityLogLoginsResponse(rsp *http.Response) (*GetActivityLogLoginsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActivityLogLoginsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count Total number of users
			Count *float32 `json:"count,omitempty"`

			// Next URL to the next users slice
			Next *string `json:"next,omitempty"`

			// Previous URL to the previous users slice
			Previous *string      `json:"previous,omitempty"`
			Result   *interface{} `json:"result,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetAuthJwtClientsClientIdLoginResponse parses an HTTP response from a GetAuthJwtClientsClientIdLoginWithResponse call
func ParseGetAuthJwtClientsClientIdLoginResponse(rsp *http.Response) (*GetAuthJwtClientsClientIdLoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthJwtClientsClientIdLoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Access Use this token to access API.
			Access *string `json:"access,omitempty"`

			// Refresh Use this token to refresh the access token via
			// [`/auth/jwt/refresh`](#tag/Account/paths/~1auth~1jwt~1refresh/post) method.
			Refresh *string `json:"refresh,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostAuthJwtLoginResponse parses an HTTP response from a PostAuthJwtLoginWithResponse call
func ParsePostAuthJwtLoginResponse(rsp *http.Response) (*PostAuthJwtLoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthJwtLoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Access Use this token to access API.
			Access *string `json:"access,omitempty"`

			// Refresh Use this token to refresh the access token via
			// [`/auth/jwt/refresh`](#tag/Account/paths/~1auth~1jwt~1refresh/post) method.
			Refresh *string `json:"refresh,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostAuthJwtRefreshResponse parses an HTTP response from a PostAuthJwtRefreshWithResponse call
func ParsePostAuthJwtRefreshResponse(rsp *http.Response) (*PostAuthJwtRefreshResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthJwtRefreshResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Access Use this token to access API.
			Access *string `json:"access,omitempty"`

			// Refresh Use this token to refresh the access token via
			// [`/auth/jwt/refresh`](#tag/Account/paths/~1auth~1jwt~1refresh/post) method.
			Refresh *string `json:"refresh,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostAuthPasswordForgotResponse parses an HTTP response from a PostAuthPasswordForgotWithResponse call
func ParsePostAuthPasswordForgotResponse(rsp *http.Response) (*PostAuthPasswordForgotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthPasswordForgotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostClientsCreateResponse parses an HTTP response from a PostClientsCreateWithResponse call
func ParsePostClientsCreateResponse(rsp *http.Response) (*PostClientsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostClientsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Company The company name.
			Company string `json:"company"`

			// Id The ID of the created account.
			Id *int `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostClientsInviteUserResponse parses an HTTP response from a PostClientsInviteUserWithResponse call
func ParsePostClientsInviteUserResponse(rsp *http.Response) (*PostClientsInviteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostClientsInviteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Status Status of the invitation.
			Status *string `json:"status,omitempty"`

			// UserId Invited user ID.
			UserId *int `json:"user_id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetClientsMeResponse parses an HTTP response from a GetClientsMeWithResponse call
func ParseGetClientsMeResponse(rsp *http.Response) (*GetClientsMeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientsMeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// BillType System field. Billing type of the account.
			BillType *string `json:"bill_type,omitempty"`

			// Capabilities System field. List of services available for the account.
			Capabilities *[]GetClientsMe200Capabilities `json:"capabilities,omitempty"`

			// CompanyName The company name.
			CompanyName *string `json:"companyName,omitempty"`

			// CountryCode System field. The company country (ISO 3166-1 alpha-2 format).
			CountryCode *string `json:"country_code,omitempty"`

			// CurrentUser ID of the current user.
			CurrentUser *int `json:"currentUser,omitempty"`

			// CustomId The account custom ID.
			CustomId *string `json:"custom_id"`

			// Deleted The field shows the status of the account:
			//   - `true` – the account has been deleted
			//   - `false` – the account is not deleted
			Deleted *bool `json:"deleted,omitempty"`

			// Email The account email.
			Email *openapi_types.Email `json:"email,omitempty"`

			// EntryBaseDomain System field. Control panel domain.
			EntryBaseDomain *string `json:"entryBaseDomain"`

			// FreeFeatures An object of arrays which contains information about free features available for the requested account.
			FreeFeatures *struct {
				CDN *[]struct {
					// CreateDate Date and time when the feature was activated (ISO 8086/RFC 3339 format).
					CreateDate *string `json:"create_date,omitempty"`

					// FeatureId Feature ID.
					FeatureId *int `json:"feature_id,omitempty"`

					// FreeFeatureId Internal feature activation ID.
					FreeFeatureId *int `json:"free_feature_id,omitempty"`

					// Name Name of the feature.
					Name    *string      `json:"name,omitempty"`
					Service *interface{} `json:"service,omitempty"`
				} `json:"CDN,omitempty"`
				CLOUD *[]struct {
					// CreateDate Date and time when the feature was activated (ISO 8086/RFC 3339 format).
					CreateDate *string `json:"create_date,omitempty"`

					// FeatureId Feature ID.
					FeatureId *int `json:"feature_id,omitempty"`

					// FreeFeatureId Internal feature activation ID.
					FreeFeatureId *int `json:"free_feature_id,omitempty"`

					// Name Name of the feature.
					Name    *string      `json:"name,omitempty"`
					Service *interface{} `json:"service,omitempty"`
				} `json:"CLOUD,omitempty"`
				DDOS *[]struct {
					// CreateDate Date and time when the feature was activated (ISO 8086/RFC 3339 format).
					CreateDate *string `json:"create_date,omitempty"`

					// FeatureId Feature ID.
					FeatureId *int `json:"feature_id,omitempty"`

					// FreeFeatureId Internal feature activation ID.
					FreeFeatureId *int `json:"free_feature_id,omitempty"`

					// Name Name of the feature.
					Name    *string      `json:"name,omitempty"`
					Service *interface{} `json:"service,omitempty"`
				} `json:"DDOS,omitempty"`
				DNS *[]struct {
					// CreateDate Date and time when the feature was activated (ISO 8086/RFC 3339 format).
					CreateDate *string `json:"create_date,omitempty"`

					// FeatureId Feature ID.
					FeatureId *int `json:"feature_id,omitempty"`

					// FreeFeatureId Internal feature activation ID.
					FreeFeatureId *int `json:"free_feature_id,omitempty"`

					// Name Name of the feature.
					Name    *string      `json:"name,omitempty"`
					Service *interface{} `json:"service,omitempty"`
				} `json:"DNS,omitempty"`
				STORAGE *[]struct {
					// CreateDate Date and time when the feature was activated (ISO 8086/RFC 3339 format).
					CreateDate *string `json:"create_date,omitempty"`

					// FeatureId Feature ID.
					FeatureId *int `json:"feature_id,omitempty"`

					// FreeFeatureId Internal feature activation ID.
					FreeFeatureId *int `json:"free_feature_id,omitempty"`

					// Name Name of the feature.
					Name    *string      `json:"name,omitempty"`
					Service *interface{} `json:"service,omitempty"`
				} `json:"STORAGE,omitempty"`
				STREAMING *[]struct {
					// CreateDate Date and time when the feature was activated (ISO 8086/RFC 3339 format).
					CreateDate *string `json:"create_date,omitempty"`

					// FeatureId Feature ID.
					FeatureId *int `json:"feature_id,omitempty"`

					// FreeFeatureId Internal feature activation ID.
					FreeFeatureId *int `json:"free_feature_id,omitempty"`

					// Name Name of the feature.
					Name    *string      `json:"name,omitempty"`
					Service *interface{} `json:"service,omitempty"`
				} `json:"STREAMING,omitempty"`
			} `json:"freeFeatures,omitempty"`

			// HasActiveAdmin System field.
			HasActiveAdmin *bool `json:"has_active_admin,omitempty"`

			// Id The account ID.
			Id *int `json:"id,omitempty"`

			// IsTest System field:
			// - `true` — a test account;
			// - `false` — a production account.
			IsTest *bool `json:"is_test,omitempty"`

			// Name Name of a user who registered the requested account.
			Name *string `json:"name"`

			// PaidFeatures An object of arrays which contains information about paid features available for the requested account.
			PaidFeatures *struct {
				CDN *[]struct {
					// CreateDate Date and time when the feature was activated (ISO 8086/RFC 3339 format).
					CreateDate *string `json:"create_date,omitempty"`

					// FeatureId Feature ID.
					FeatureId *int `json:"feature_id,omitempty"`

					// Name Name of the feature.
					Name *string `json:"name,omitempty"`

					// PaidFeatureId Internal feature activation ID.
					PaidFeatureId *int         `json:"paid_feature_id,omitempty"`
					Service       *interface{} `json:"service,omitempty"`
				} `json:"CDN,omitempty"`
				CLOUD *[]struct {
					// CreateDate Date and time when the feature was activated (ISO 8086/RFC 3339 format).
					CreateDate *string `json:"create_date,omitempty"`

					// FeatureId Feature ID.
					FeatureId *int `json:"feature_id,omitempty"`

					// Name Name of the feature.
					Name *string `json:"name,omitempty"`

					// PaidFeatureId Internal feature activation ID.
					PaidFeatureId *int         `json:"paid_feature_id,omitempty"`
					Service       *interface{} `json:"service,omitempty"`
				} `json:"CLOUD,omitempty"`
				DDOS *[]struct {
					// CreateDate Date and time when the feature was activated (ISO 8086/RFC 3339 format).
					CreateDate *string `json:"create_date,omitempty"`

					// FeatureId Feature ID.
					FeatureId *int `json:"feature_id,omitempty"`

					// Name Name of the feature.
					Name *string `json:"name,omitempty"`

					// PaidFeatureId Internal feature activation ID.
					PaidFeatureId *int         `json:"paid_feature_id,omitempty"`
					Service       *interface{} `json:"service,omitempty"`
				} `json:"DDOS,omitempty"`
				DNS *[]struct {
					// CreateDate Date and time when the feature was activated (ISO 8086/RFC 3339 format).
					CreateDate *string `json:"create_date,omitempty"`

					// FeatureId Feature ID.
					FeatureId *int `json:"feature_id,omitempty"`

					// Name Name of the feature.
					Name *string `json:"name,omitempty"`

					// PaidFeatureId Internal feature activation ID.
					PaidFeatureId *int         `json:"paid_feature_id,omitempty"`
					Service       *interface{} `json:"service,omitempty"`
				} `json:"DNS,omitempty"`
				STORAGE *[]struct {
					// CreateDate Date and time when the feature was activated (ISO 8086/RFC 3339 format).
					CreateDate *string `json:"create_date,omitempty"`

					// FeatureId Feature ID.
					FeatureId *int `json:"feature_id,omitempty"`

					// Name Name of the feature.
					Name *string `json:"name,omitempty"`

					// PaidFeatureId Internal feature activation ID.
					PaidFeatureId *int         `json:"paid_feature_id,omitempty"`
					Service       *interface{} `json:"service,omitempty"`
				} `json:"STORAGE,omitempty"`
				STREAMING *[]struct {
					// CreateDate Date and time when the feature was activated (ISO 8086/RFC 3339 format).
					CreateDate *string `json:"create_date,omitempty"`

					// FeatureId Feature ID.
					FeatureId *int `json:"feature_id,omitempty"`

					// Name Name of the feature.
					Name *string `json:"name,omitempty"`

					// PaidFeatureId Internal feature activation ID.
					PaidFeatureId *int         `json:"paid_feature_id,omitempty"`
					Service       *interface{} `json:"service,omitempty"`
				} `json:"STREAMING,omitempty"`
			} `json:"paidFeatures,omitempty"`

			// Phone Phone of a user who registered the requested account.
			Phone *string `json:"phone"`

			// ServiceStatuses An object of arrays which contains information about all services available for the requested account.
			ServiceStatuses *struct {
				CDN *struct {
					// Enabled `true` - service is available in the Control Panel.
					Enabled *bool `json:"enabled,omitempty"`

					// Status Status of the service.
					Status *GetClientsMe200ServiceStatusesCDNStatus `json:"status,omitempty"`
				} `json:"CDN,omitempty"`
				CLOUD *struct {
					// Enabled `true` - service is available in the Control Panel.
					Enabled *bool `json:"enabled,omitempty"`

					// Status Status of the service.
					Status *GetClientsMe200ServiceStatusesCLOUDStatus `json:"status,omitempty"`
				} `json:"CLOUD,omitempty"`
				DDOS *struct {
					// Enabled `true` - service is available in the Control Panel.
					Enabled *bool `json:"enabled,omitempty"`

					// Status Status of the service.
					Status *GetClientsMe200ServiceStatusesDDOSStatus `json:"status,omitempty"`
				} `json:"DDOS,omitempty"`
				DNS *struct {
					// Enabled `true` - service is available in the Control Panel.
					Enabled *bool `json:"enabled,omitempty"`

					// Status Status of the service.
					Status *GetClientsMe200ServiceStatusesDNSStatus `json:"status,omitempty"`
				} `json:"DNS,omitempty"`
				STORAGE *struct {
					// Enabled `true` - service is available in the Control Panel.
					Enabled *bool `json:"enabled,omitempty"`

					// Status Status of the service.
					Status *GetClientsMe200ServiceStatusesSTORAGEStatus `json:"status,omitempty"`
				} `json:"STORAGE,omitempty"`
				STREAMING *struct {
					// Enabled `true` - service is available in the Control Panel.
					Enabled *bool `json:"enabled,omitempty"`

					// Status Status of the service.
					Status *GetClientsMe200ServiceStatusesSTREAMINGStatus `json:"status,omitempty"`
				} `json:"STREAMING,omitempty"`
			} `json:"serviceStatuses,omitempty"`

			// SignupProcess System field. Type of the account registration process.
			SignupProcess *GetClientsMe200SignupProcess `json:"signup_process"`

			// Status Status of the account.
			Status *GetClientsMe200Status `json:"status,omitempty"`

			// Users List of account users.
			Users *[]struct {
				// Activated Email confirmation:
				// - `true` – user confirmed the email;
				// - `false` – user did not confirm the email.
				Activated *bool `json:"activated,omitempty"`

				// AuthTypes System field. List of auth types available for the account.
				AuthTypes *[]GetClientsMe200UsersAuthTypes `json:"auth_types,omitempty"`

				// Client User's  account ID.
				Client *float32 `json:"client,omitempty"`

				// Company User's company.
				Company *string `json:"company,omitempty"`

				// Deleted Deletion flag. If `true` then user was deleted.
				Deleted *bool `json:"deleted,omitempty"`

				// Email User's email address.
				Email *openapi_types.Email `json:"email,omitempty"`

				// Groups User's group in the current account.
				//
				// IAM supports 5 groups:
				//
				//   - Users
				//   - Administrators
				//   - Engineers
				//   - Purge and Prefetch only (API)
				//   - Purge and Prefetch only (API+Web)
				Groups *[]struct {
					// Id Group&#39;s ID: Possible values are: <br> <ul> <li>1 - Administrators <li>2 - Users <li>5 - Engineers <li>3009 - Purge and Prefetch only (API+Web) <li>3022 - Purge and Prefetch only (API)
					Id *int `json:"id,omitempty"`

					// Name Group's name.
					Name *GetClientsMe200UsersGroupsName `json:"name,omitempty"`
				} `json:"groups,omitempty"`

				// Id User's ID.
				Id *int `json:"id,omitempty"`

				// Lang User's language.
				//
				// Defines language of the control panel and email messages.
				Lang *GetClientsMe200UsersLang `json:"lang,omitempty"`

				// Name User's name.
				Name *string `json:"name"`

				// Phone User's phone.
				Phone *string `json:"phone"`

				// Reseller Services provider ID.
				Reseller *int `json:"reseller,omitempty"`

				// SsoAuth SSO authentication flag. If `true` then user can login via SAML SSO.
				SsoAuth *bool `json:"sso_auth,omitempty"`

				// TwoFa Two-step verification:
				//   - `true` – user enabled two-step verification;
				//   - `false` – user disabled two-step verification.
				TwoFa *bool `json:"two_fa,omitempty"`
			} `json:"users,omitempty"`

			// Website The company website.
			Website *string `json:"website,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteClientsClientIdClientUsersUserIdResponse parses an HTTP response from a DeleteClientsClientIdClientUsersUserIdWithResponse call
func ParseDeleteClientsClientIdClientUsersUserIdResponse(rsp *http.Response) (*DeleteClientsClientIdClientUsersUserIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClientsClientIdClientUsersUserIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetClientsClientIdClientUsersUserIdResponse parses an HTTP response from a GetClientsClientIdClientUsersUserIdWithResponse call
func ParseGetClientsClientIdClientUsersUserIdResponse(rsp *http.Response) (*GetClientsClientIdClientUsersUserIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientsClientIdClientUsersUserIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			UserRole *struct {
				// Id Group&#39;s ID: Possible values are: <br> <ul> <li>1 - Administrators <li>2 - Users <li>5 - Engineers <li>3009 - Purge and Prefetch only (API+Web) <li>3022 - Purge and Prefetch only (API)
				Id *int `json:"id,omitempty"`

				// Name Group's name.
				Name *GetClientsClientIdClientUsersUserId200UserRoleName `json:"name,omitempty"`
			} `json:"user_role,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePutClientsClientIdClientUsersUserIdResponse parses an HTTP response from a PutClientsClientIdClientUsersUserIdWithResponse call
func ParsePutClientsClientIdClientUsersUserIdResponse(rsp *http.Response) (*PutClientsClientIdClientUsersUserIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutClientsClientIdClientUsersUserIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Errors This object contains error descriptions per field from your request.
			Errors *struct {
				// PropertyName Error list for a specific field.
				PropertyName *[]string `json:"property_name,omitempty"`
			} `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetClientsClientIdTokensResponse parses an HTTP response from a GetClientsClientIdTokensWithResponse call
func ParseGetClientsClientIdTokensResponse(rsp *http.Response) (*GetClientsClientIdTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientsClientIdTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// ClientUser API token role and issuer data.
			ClientUser struct {
				// ClientId Account's ID.
				ClientId *int `json:"client_id,omitempty"`

				// Deleted Deletion flag. If true, then the API token was deleted.
				Deleted *bool `json:"deleted,omitempty"`
				Role    *struct {
					// Id Group&#39;s ID: Possible values are: <br> <ul> <li>1 - Administrators <li>2 - Users <li>5 - Engineers <li>3009 - Purge and Prefetch only (API+Web) <li>3022 - Purge and Prefetch only (API)
					Id *int `json:"id,omitempty"`

					// Name Group's name.
					Name *GetClientsClientIdTokens200ClientUserRoleName `json:"name,omitempty"`
				} `json:"role,omitempty"`

				// UserEmail User's email who issued the API token.
				UserEmail *string `json:"user_email,omitempty"`

				// UserId User's ID who issued the API token.
				UserId *int `json:"user_id,omitempty"`

				// UserName User's name who issued the API token.
				UserName *string `json:"user_name,omitempty"`
			} `json:"client_user"`

			// Created Date when the API token was issued (ISO 8086/RFC 3339 format), UTC.
			Created *string `json:"created,omitempty"`

			// Deleted Deletion flag. If true, then the API token was deleted.
			Deleted *bool `json:"deleted,omitempty"`

			// Description API token description.
			Description *string `json:"description,omitempty"`

			// ExpDate Date when the API token becomes expired (ISO 8086/RFC 3339 format), UTC.
			// If null, then the API token will never expire.
			ExpDate *string `json:"exp_date,omitempty"`

			// Expired Expiration flag. If true, then the API token has expired.
			// When an API token expires it will be automatically deleted.
			Expired *bool `json:"expired,omitempty"`

			// Id API token ID.
			Id *int `json:"id,omitempty"`

			// LastUsage Date when the API token was last used (ISO 8086/RFC 3339 format), UTC.
			LastUsage *string `json:"last_usage,omitempty"`

			// Name API token name.
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostClientsClientIdTokensResponse parses an HTTP response from a PostClientsClientIdTokensWithResponse call
func ParsePostClientsClientIdTokensResponse(rsp *http.Response) (*PostClientsClientIdTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostClientsClientIdTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Token API token.
			// Copy it, because you will not be able to get it again.
			// We do not store tokens. All responsibility for token storage and usage is on the issuer.
			Token *string `json:"token,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteClientsClientIdTokensTokenIdResponse parses an HTTP response from a DeleteClientsClientIdTokensTokenIdWithResponse call
func ParseDeleteClientsClientIdTokensTokenIdResponse(rsp *http.Response) (*DeleteClientsClientIdTokensTokenIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClientsClientIdTokensTokenIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetClientsClientIdTokensTokenIdResponse parses an HTTP response from a GetClientsClientIdTokensTokenIdWithResponse call
func ParseGetClientsClientIdTokensTokenIdResponse(rsp *http.Response) (*GetClientsClientIdTokensTokenIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientsClientIdTokensTokenIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ClientUser API token role and issuer data.
			ClientUser struct {
				// ClientId Account's ID.
				ClientId *int `json:"client_id,omitempty"`

				// Deleted Deletion flag. If true, then the API token was deleted.
				Deleted *bool `json:"deleted,omitempty"`
				Role    *struct {
					// Id Group&#39;s ID: Possible values are: <br> <ul> <li>1 - Administrators <li>2 - Users <li>5 - Engineers <li>3009 - Purge and Prefetch only (API+Web) <li>3022 - Purge and Prefetch only (API)
					Id *int `json:"id,omitempty"`

					// Name Group's name.
					Name *GetClientsClientIdTokensTokenId200ClientUserRoleName `json:"name,omitempty"`
				} `json:"role,omitempty"`

				// UserEmail User's email who issued the API token.
				UserEmail *string `json:"user_email,omitempty"`

				// UserId User's ID who issued the API token.
				UserId *int `json:"user_id,omitempty"`

				// UserName User's name who issued the API token.
				UserName *string `json:"user_name,omitempty"`
			} `json:"client_user"`

			// Created Date when the API token was issued (ISO 8086/RFC 3339 format), UTC.
			Created *string `json:"created,omitempty"`

			// Deleted Deletion flag. If true, then the API token was deleted.
			Deleted *bool `json:"deleted,omitempty"`

			// Description API token description.
			Description *string `json:"description,omitempty"`

			// ExpDate Date when the API token becomes expired (ISO 8086/RFC 3339 format), UTC.
			// If null, then the API token will never expire.
			ExpDate *string `json:"exp_date,omitempty"`

			// Expired Expiration flag. If true, then the API token has expired.
			// When an API token expires it will be automatically deleted.
			Expired *bool `json:"expired,omitempty"`

			// Id API token ID.
			Id *int `json:"id,omitempty"`

			// LastUsage Date when the API token was last used (ISO 8086/RFC 3339 format), UTC.
			LastUsage *string `json:"last_usage,omitempty"`

			// Name API token name.
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUsersResponse parses an HTTP response from a GetUsersWithResponse call
func ParseGetUsersResponse(rsp *http.Response) (*GetUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUsersUserIdResponse parses an HTTP response from a GetUsersUserIdWithResponse call
func ParseGetUsersUserIdResponse(rsp *http.Response) (*GetUsersUserIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersUserIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Activated Email confirmation:
			// - `true` – user confirmed the email;
			// - `false` – user did not confirm the email.
			Activated *bool `json:"activated,omitempty"`

			// AuthTypes System field. List of auth types available for the account.
			AuthTypes *[]GetUsersUserId200AuthTypes `json:"auth_types,omitempty"`

			// Client User's  account ID.
			Client *float32 `json:"client,omitempty"`

			// ClientAndRoles List of user's clients. User can access to one or more clients.
			ClientAndRoles *[]struct {
				ClientCompanyName string `json:"client_company_name"`
				ClientId          int    `json:"client_id"`

				// UserId User's ID.
				UserId int `json:"user_id"`

				// UserRoles User role in this client.
				UserRoles []string `json:"user_roles"`
			} `json:"client_and_roles,omitempty"`

			// Company User's company.
			Company *string `json:"company,omitempty"`

			// Deleted Deletion flag. If `true` then user was deleted.
			Deleted *bool `json:"deleted,omitempty"`

			// Email User's email address.
			Email *openapi_types.Email `json:"email,omitempty"`

			// Groups User's group in the current account.
			//
			// IAM supports 5 groups:
			//
			//   - Users
			//   - Administrators
			//   - Engineers
			//   - Purge and Prefetch only (API)
			//   - Purge and Prefetch only (API+Web)
			Groups *[]struct {
				// Id Group&#39;s ID: Possible values are: <br> <ul> <li>1 - Administrators <li>2 - Users <li>5 - Engineers <li>3009 - Purge and Prefetch only (API+Web) <li>3022 - Purge and Prefetch only (API)
				Id *int `json:"id,omitempty"`

				// Name Group's name.
				Name *GetUsersUserId200GroupsName `json:"name,omitempty"`
			} `json:"groups,omitempty"`

			// Id User's ID.
			Id *int `json:"id,omitempty"`

			// IsActive User activity flag.
			IsActive *bool `json:"is_active,omitempty"`

			// Lang User's language.
			//
			// Defines language of the control panel and email messages.
			Lang *GetUsersUserId200Lang `json:"lang,omitempty"`

			// Name User's name.
			Name *string `json:"name"`

			// Phone User's phone.
			Phone *string `json:"phone"`

			// Reseller Services provider ID.
			Reseller *int `json:"reseller,omitempty"`

			// SsoAuth SSO authentication flag. If `true` then user can login via SAML SSO.
			SsoAuth *bool `json:"sso_auth,omitempty"`

			// TwoFa Two-step verification:
			//   - `true` – user enabled two-step verification;
			//   - `false` – user disabled two-step verification.
			TwoFa *bool `json:"two_fa,omitempty"`

			// UserType User's type.
			UserType *GetUsersUserId200UserType `json:"user_type,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchUsersUserIdResponse parses an HTTP response from a PatchUsersUserIdWithResponse call
func ParsePatchUsersUserIdResponse(rsp *http.Response) (*PatchUsersUserIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchUsersUserIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Activated Email confirmation:
			// - `true` – user confirmed the email;
			// - `false` – user did not confirm the email.
			Activated *bool `json:"activated,omitempty"`

			// AuthTypes System field. List of auth types available for the account.
			AuthTypes *[]PatchUsersUserId200AuthTypes `json:"auth_types,omitempty"`

			// Client User's  account ID.
			Client *float32 `json:"client,omitempty"`

			// ClientAndRoles List of user's clients. User can access to one or more clients.
			ClientAndRoles *[]struct {
				ClientCompanyName string `json:"client_company_name"`
				ClientId          int    `json:"client_id"`

				// UserId User's ID.
				UserId int `json:"user_id"`

				// UserRoles User role in this client.
				UserRoles []string `json:"user_roles"`
			} `json:"client_and_roles,omitempty"`

			// Company User's company.
			Company *string `json:"company,omitempty"`

			// Deleted Deletion flag. If `true` then user was deleted.
			Deleted *bool `json:"deleted,omitempty"`

			// Email User's email address.
			Email *openapi_types.Email `json:"email,omitempty"`

			// Groups User's group in the current account.
			//
			// IAM supports 5 groups:
			//
			//   - Users
			//   - Administrators
			//   - Engineers
			//   - Purge and Prefetch only (API)
			//   - Purge and Prefetch only (API+Web)
			Groups *[]struct {
				// Id Group&#39;s ID: Possible values are: <br> <ul> <li>1 - Administrators <li>2 - Users <li>5 - Engineers <li>3009 - Purge and Prefetch only (API+Web) <li>3022 - Purge and Prefetch only (API)
				Id *int `json:"id,omitempty"`

				// Name Group's name.
				Name *PatchUsersUserId200GroupsName `json:"name,omitempty"`
			} `json:"groups,omitempty"`

			// Id User's ID.
			Id *int `json:"id,omitempty"`

			// IsActive User activity flag.
			IsActive *bool `json:"is_active,omitempty"`

			// Lang User's language.
			//
			// Defines language of the control panel and email messages.
			Lang *PatchUsersUserId200Lang `json:"lang,omitempty"`

			// Name User's name.
			Name *string `json:"name"`

			// Phone User's phone.
			Phone *string `json:"phone"`

			// Reseller Services provider ID.
			Reseller *int `json:"reseller,omitempty"`

			// SsoAuth SSO authentication flag. If `true` then user can login via SAML SSO.
			SsoAuth *bool `json:"sso_auth,omitempty"`

			// TwoFa Two-step verification:
			//   - `true` – user enabled two-step verification;
			//   - `false` – user disabled two-step verification.
			TwoFa *bool `json:"two_fa,omitempty"`

			// UserType User's type.
			UserType *PatchUsersUserId200UserType `json:"user_type,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePutUsersUserIdEmailResponse parses an HTTP response from a PutUsersUserIdEmailWithResponse call
func ParsePutUsersUserIdEmailResponse(rsp *http.Response) (*PutUsersUserIdEmailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutUsersUserIdEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NewEmail User's new email.
			NewEmail *string `json:"new_email,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePutUsersUserIdPasswordResponse parses an HTTP response from a PutUsersUserIdPasswordWithResponse call
func ParsePutUsersUserIdPasswordResponse(rsp *http.Response) (*PutUsersUserIdPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutUsersUserIdPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Access Use this token to access API.
			Access *string `json:"access,omitempty"`

			// Refresh Use this token to refresh the access token via
			// [`/auth/jwt/refresh`](#tag/Account/paths/~1auth~1jwt~1refresh/post) method.
			Refresh *string `json:"refresh,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"fydss6x///r9/w8AAP//+pgGgxZNAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
